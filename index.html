<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Sling Drive Navigator</title>

<style>
  body {
    background: #262626;
    color: #ffcc00;
    margin: 0;
    padding: 0px;
    line-height: 1.1;
    font-family: monospace;
    font-weight: 800;
    letter-spacing: 0.05em;
    text-shadow: 0 0 2px #EBFA7A; /* PATCH [9] glow across webpage */
    overflow-x: hidden;
  }

  h1 {
    font-family: monospace;
    font-weight: 1000;
    letter-spacing: 0.05em;
    color: #ffcc00;
    text-shadow: 0 0 3px #EBFA7A;
    margin-top: 30px;
    letter-spacing: 1px;
  }

  p.small {
    font-size: 0.9em;
    opacity: 0.8;
    margin-bottom: 20px;
  }

  .micro {
    font-size: 0.65em;
    opacity: 0.7;
    letter-spacing: 0.08em;
  }

  p.bodytext {
    margin-top: 20px;
    font-size: 1.3em;
  }

  .typeout {
    display: block;
    overflow: hidden;
    white-space: nowrap;
    height: 1.4em;
    width: min(32ch, 100%);
    font-family: monospace;
    font-size: 1.1em;
    font-weight: 600;
    letter-spacing: 0.05em;
    text-shadow: 0 0 4px #EBFA7A;
    animation: typing 6s steps(60, end) infinite;
  }

  .typeout::after {
    content: "▉";
    display: inline-block;
    margin-left: 4px;
    color: #ffcc00;
    text-shadow: 0 0 4px #EBFA7A;
    animation: cursorBlink 0.8s step-end infinite;
  }

  @keyframes typing {
    0%  { width: 0;   opacity: 1; }
    40% { width: 100%; opacity: 1; }
    60% { width: 100%; opacity: 1; }
    90% { width: 100%; opacity: 1; }
    95% { width: 100%; opacity: 0; }
    100%{ width: 100%; opacity: 0; }
  }

  @keyframes cursorBlink {
    0%, 50% { opacity: 1; }
    50%, 100% { opacity: 0; }
  }

  .button {
    display: inline-block;
    margin-top: 40px;
    padding: 14px 24px;
    background: #ffcc00;
    color: #262626;
    text-decoration: none;
    font-weight: bold;
    font-family: monospace;
    letter-spacing: 0.05em;
    border-radius: 0px;
    text-shadow: 0 0 3px #322B1A;
    border: 2px solid #ffcc00;
    box-shadow: 0 0 3px #EBFA7A, 0 0 0px #EBFA7A inset;
  }

  .button:hover {
    background: #e6b800;
    border-color: #e6b800;
  }

  .scale-container { overflow: visible; }

  .container {
    max-width: 650px;
    margin: 0 auto;
    padding: 50px;
    transform: scale(1.2);
    transform-origin: top center;
  }

  .teku-header {
    font-family: monospace;
    font-size: 0.85em;
    font-weight: 900;
    letter-spacing: 0.2em;
    opacity: 0.8;
    text-align: left;
    margin-bottom: 10px;
  }

  .divider {
    border: none;
    border-bottom: 1px solid #ffcc00;
    opacity: 0.3;
    margin-bottom: 20px;
  }

  .crt {
    position: relative;
    overflow: hidden;
    min-height: 100vh;
    width: 100%;
    animation: crtFlicker 0.15s infinite;
  }

  .crt::before {
    content: "";
    position: absolute;
    inset: 0;
    pointer-events: none;
    background: repeating-linear-gradient(
      to bottom,
      rgba(255, 255, 255, 0.03) 0px,
      rgba(255, 255, 255, 0.03) 1px,
      rgba(0, 0, 0, 0) 2px
    );
    opacity: 0.25;
    mix-blend-mode: overlay;
  }

  .crt::after {
    content: "";
    position: absolute;
    inset: 0;
    pointer-events: none;
    background: radial-gradient(
      circle at center,
      rgba(255, 255, 255, 0.05) 0%,
      rgba(0, 0, 0, 0.8) 100%
    );
    opacity: 0.3;
  }

  @keyframes crtFlicker {
    0% { opacity: 0.96; }
    50% { opacity: 1; }
    100% { opacity: 0.97; }
  }

  /* ---------- SOLAR MAP ---------- */
  #solar-map { margin-top: 22px; }

  .map-frame {
    border: 1px solid rgba(255, 204, 0, 0.35);
    box-shadow: 0 0 3px rgba(235, 250, 122, 0.25);
    padding: 10px 10px 8px 10px;
    position: relative; /* PATCH [9] for bottom-right zoom controls */
  }

  .map-topline {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    gap: 12px;
    margin-bottom: 8px;
    font-weight: 900;
    letter-spacing: 0.12em;
    font-size: 0.85em;
    opacity: 0.85;
    user-select: none;
  }

  .map-topline .date-click {
    cursor: pointer;
    border-bottom: 1px solid rgba(255,204,0,0.25);
  }
  .map-topline .date-click:hover {
    border-bottom-color: rgba(255,204,0,0.6);
  }

  .map-controls {
    display: flex;
    gap: 8px;
    align-items: center;
    justify-content: flex-end;
    flex-wrap: wrap;
    font-size: 0.85em;
    opacity: 0.85;
    letter-spacing: 0.10em;
  }

  .map-controls .ctrlbtn {
    cursor: pointer;
    border: 1px solid rgba(255, 204, 0, 0.25);
    padding: 4px 8px;
    box-shadow: 0 0 2px rgba(235, 250, 122, 0.15);
    user-select: none;
  }
  .map-controls .ctrlbtn:hover {
    border-color: rgba(255, 204, 0, 0.6);
  }

  .map-svg-wrap {
    width: 100%;
    height: clamp(320px, 58vh, 520px);
    position: relative;
    overflow: hidden;
    touch-action: none;
  }

  svg#solar-svg {
    width: 100%;
    height: 100%;
    display: block;
  }

  /* PATCH [9] zoom buttons moved to bottom-right; keep them clickable above pointer capture */
  .map-zoompad {
    position: absolute;
    right: 10px;
    bottom: 10px;
    display: flex;
    flex-direction: column;
    gap: 6px;
    z-index: 50;
    pointer-events: auto;
  }
  .map-zoompad .zbtn {
    cursor: pointer;
    border: 1px solid rgba(255, 204, 0, 0.25);
    padding: 6px 10px;
    box-shadow: 0 0 2px rgba(235, 250, 122, 0.15);
    user-select: none;
    background: rgba(38,38,38,0.55);
    text-align: center;
    font-weight: 1000;
    letter-spacing: 0.10em;
  }
  .map-zoompad .zbtn:hover {
    border-color: rgba(255, 204, 0, 0.6);
  }

  .readout {
    margin-top: 10px;
    padding: 10px 10px 8px 10px;
    border-top: 1px solid rgba(255,204,0,0.18);
    border-bottom: 1px solid rgba(255,204,0,0.18);
    letter-spacing: 0.10em;
    font-size: 0.95em;
    opacity: 0.95;
    text-shadow: 0 0 4px rgba(235,250,122,0.35);
  }

  .readout .title {
    font-weight: 1000;
    opacity: 0.95;
    margin-bottom: 6px;
  }

  .readout .line {
    display: flex;
    justify-content: space-between;
    gap: 12px;
    margin: 2px 0;
    flex-wrap: wrap;
  }

  .readout .k {
    opacity: 0.85;
    min-width: 10ch;
  }

  .readout .v {
    font-weight: 1000;
  }

  .map-bottom {
    margin-top: 10px;
    padding-top: 8px;
    font-size: 0.85em;
    letter-spacing: 0.10em;
    opacity: 0.90;
    display: grid;
    grid-template-columns: 1fr;
    gap: 6px;
  }

  .map-bottom .row {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    align-items: baseline;
    justify-content: space-between;
  }

  .map-bottom label {
    opacity: 0.9;
    margin-right: 6px;
  }

  .map-bottom select {
    background: transparent;
    color: #ffcc00;
    border: 1px solid rgba(255,204,0,0.25);
    font-family: monospace;
    font-weight: 800;
    padding: 4px 6px;
    letter-spacing: 0.08em;
    outline: none;
    text-shadow: 0 0 4px rgba(235,250,122,0.35);
  }

  .map-bottom select option {
    background: #262626;
    color: #ffcc00;
    text-shadow: 0 0 4px rgba(235,250,122,0.35);
  }

  .hint {
    opacity: 0.75;
    font-size: 0.8em;
    letter-spacing: 0.10em;
  }

  /* ---------- MOBILE UI OPTIMISATION (≤600px) ---------- */
  @media (max-width: 600px) {
    body { font-size: 8px; padding: 0; margin: 0; }
    .teku-header { font-size: 1.3em; letter-spacing: 0.15em; }
    p.small { font-size: 1.0em; }
    h1 { font-size: 2em; line-height: 1.3; }
    p.bodytext { font-size: 1.3em; }
    .typeout { font-size: 1.3em; }
    .button { font-size: 1.4em; padding: 16px 24px; }
    .container { transform: none; padding: 20px; }
    .map-topline { font-size: 1.0em; }
    .map-controls { font-size: 1.0em; }
    .map-bottom { font-size: 1.0em; }
    .readout { font-size: 1.05em; }
  }
</style>
</head>

<body>
  <div class="scale-container">
    <div class="crt">
      <div class="container">

        <p class="teku-header">UNREGISTERED TEKU SLATE</p>
        <hr class="divider">
        <p class="small">TEKUDEX Default Guide "EID-SN4SD/Nav/Tw2%c"</p>

        <p class="micro">
░░████████╗███████╗██╗░░██╗██╗░░░██╗██████╗░███████╗██╗░░██╗░░
░░╚══██╔══╝██╔════╝██║░██╔╝██║░░░██║██╔══██╗██╔════╝╚██╗██╔╝░░
░░░░░██║░░░█████╗░░█████═╝░██║░░░██║██║░░██║█████╗░░░╚███╔╝░░░
░░░░░██║░░░██╔══╝░░██╔═██╗░██║░░░██║██║░░██║██╔══╝░░░██╔██╗░░░
░░░░░██║░░░███████╗██║░╚██╗╚██████╔╝██████╔╝███████╗██╔╝╚██╗░░
░░░░░╚═╝░░░╚══════╝╚═╝░░╚═╝░╚═════╝░╚═════╝░╚══════╝╚═╝░░╚═╝░░
        </p>

        <div style="height: 40px;"></div>

        <h1>Sling Drive Navigator (Tw2%c)</h1>

        <p class="bodytext">
          This interactive TEKUDEX entry in the Solar Nomad Series is designed for easy reference in the quartermastery and piloting of vessels fitted with a [TWIN_SPOOL] Sling Drive configuration and [N/S_250] Minkowski Tokamak, with a maximum relative velocity of [2%c].
        </p>

        <div id="solar-map"></div>

        <div style="height: 20px;"></div>

        <!-- PATCH [16] -->
        <p class="typeout">▉ ▉ ▉ Calibrated </p>

        <div style="height: 100px;"></div>

      </div>
    </div>
  </div>

<script>
(() => {
  "use strict";

  // ---------------------------
  // 0) Utilities
  // ---------------------------
  const DEG = Math.PI / 180;

  function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }
  function modAngleDeg(x){
    let y = ((x + 180) % 360 + 360) % 360 - 180;
    return y;
  }
  function fmtSign(n, dp=3){
    const s = n >= 0 ? "+" : "−";
    return s + Math.abs(n).toFixed(dp);
  }
  function fmtFixed(n, dp){ return Number(n).toFixed(dp); }
  function fmtAU1(n){
    return (Math.round(n * 10) / 10).toFixed(1);
  }
  function pad2(n){ return String(n).padStart(2, "0"); }

  function toJulianDay(year, month, day){
    let a = Math.floor((14 - month) / 12);
    let y = year + 4800 - a;
    let m = month + 12*a - 3;
    let JDN = day + Math.floor((153*m + 2)/5) + 365*y + Math.floor(y/4) - Math.floor(y/100) + Math.floor(y/400) - 32045;
    return JDN - 0.5;
  }

  function jdToYMD(jd){
    const JDN = Math.floor(jd + 0.5);
    let f = JDN + 1401 + Math.floor((Math.floor((4*JDN + 274277)/146097)*3)/4) - 38;
    let e = 4*f + 3;
    let g = Math.floor((e % 1461)/4);
    let h = 5*g + 2;
    let D = Math.floor((h % 153)/5) + 1;
    let M = (Math.floor(h/153) + 2) % 12 + 1;
    let Y = Math.floor(e/1461) - 4716 + Math.floor((12 + 2 - M)/12);
    return {y:Y, m:M, d:D};
  }

  function parseYMD(s){
    const m = /^\s*(\d{4})-(\d{2})-(\d{2})\s*$/.exec(s || "");
    if(!m) return null;
    const y = Number(m[1]), mo = Number(m[2]), d = Number(m[3]);
    if(mo < 1 || mo > 12 || d < 1 || d > 31) return null;
    return {y, m:mo, d};
  }

  // ---------------------------
  // 1) Orbital model
  // JPL Standish "Approximate positions" Table 2a/2b for 3000 BC - 3000 AD
  // ---------------------------
  const JPL_T2A = {
    Mercury:  { a0:0.38709843, aDot:0.00000000, e0:0.20563661, eDot:0.00002123, I0:7.00559432, IDot:-0.00590158, L0:252.25166724, LDot:149472.67486623, wbar0:77.45771895, wbarDot:0.15940013, Omega0:48.33961819, OmegaDot:-0.12214182 },
    Venus:    { a0:0.72332102, aDot:-0.00000026, e0:0.00676399, eDot:-0.00005107, I0:3.39777545, IDot:0.00043494, L0:181.97970850, LDot:58517.81560260, wbar0:131.76755713, wbarDot:0.05679648, Omega0:76.67261496, OmegaDot:-0.27274174 },
    Earth:    { a0:1.00000018, aDot:-0.00000003, e0:0.01673163, eDot:-0.00003661, I0:-0.00054346, IDot:-0.01337178, L0:100.46691572, LDot:35999.37306329, wbar0:102.93005885, wbarDot:0.31795260, Omega0:-5.11260389, OmegaDot:-0.24123856 },
    Mars:     { a0:1.52371243, aDot:0.00000097, e0:0.09336511, eDot:0.00009149, I0:1.85181869, IDot:-0.00724757, L0:-4.56813164, LDot:19140.29934243, wbar0:-23.91744784, wbarDot:0.45223625, Omega0:49.71320984, OmegaDot:-0.26852431 },
    Jupiter:  { a0:5.20248019, aDot:-0.00002864, e0:0.04853590, eDot:0.00018026, I0:1.29861416, IDot:-0.00322699, L0:34.33479152, LDot:3034.90371757, wbar0:14.27495244, wbarDot:0.18199196, Omega0:100.29282654, OmegaDot:0.13024619 },
    Saturn:   { a0:9.54149883, aDot:-0.00003065, e0:0.05550825, eDot:-0.00032044, I0:2.49424102, IDot:0.00451969, L0:50.07571329, LDot:1222.11494724, wbar0:92.86136063, wbarDot:0.54179478, Omega0:113.63998702, OmegaDot:-0.25015002 },
    Uranus:   { a0:19.18797948, aDot:-0.00020455, e0:0.04685740, eDot:-0.00001550, I0:0.77298127, IDot:-0.00180155, L0:314.20276625, LDot:428.49512595, wbar0:172.43404441, wbarDot:0.09266985, Omega0:73.96250215, OmegaDot:0.05739699 },
    Neptune:  { a0:30.06952752, aDot:0.00006447, e0:0.00895439, eDot:0.00000818, I0:1.77005520, IDot:0.00022400, L0:304.22289287, LDot:218.46515314, wbar0:46.68158724, wbarDot:0.01009938, Omega0:131.78635853, OmegaDot:-0.00606302 }
  };

  const JPL_T2B = {
    Jupiter: { b:-0.00012452, c:0.06064060, s:-0.35635438, f:38.35125000 },
    Saturn:  { b: 0.00025899, c:-0.13434469, s: 0.87320147, f:38.35125000 },
    Uranus:  { b: 0.00058331, c:-0.97731848, s: 0.17689245, f: 7.67025000 },
    Neptune: { b:-0.00041348, c:0.68346318, s:-0.10162547, f: 7.67025000 }
  };

  function makeKeplerBody({name, a, e, I, Omega, omega, epoch_jd, M0_deg}){
    const P_years = Math.sqrt(a*a*a);
    const P_days  = P_years * 365.25;
    const n = 360.0 / P_days;
    return { name, a, e, I, Omega, omega, epoch_jd, M0_deg, n };
  }

  function solveKeplerE(Mdeg, e){
    let M = Mdeg * DEG;
    let E = M + e * Math.sin(M);
    for(let i=0;i<15;i++){
      let f = E - e*Math.sin(E) - M;
      let fp = 1 - e*Math.cos(E);
      let dE = -f / fp;
      E += dE;
      if(Math.abs(dE) < 1e-12) break;
    }
    return E;
  }

  function posFromElements(a, e, Ideg, OmegaDeg, omegaDeg, Mdeg){
    const I = Ideg*DEG, Om = OmegaDeg*DEG, w = omegaDeg*DEG;
    const E = solveKeplerE(Mdeg, e);

    const xprime = a * (Math.cos(E) - e);
    const yprime = a * Math.sqrt(1 - e*e) * Math.sin(E);

    const cosw = Math.cos(w),  sinw = Math.sin(w);
    const cosO = Math.cos(Om), sinO = Math.sin(Om);
    const cosI = Math.cos(I),  sinI = Math.sin(I);

    const x = (cosw*cosO - sinw*sinO*cosI)*xprime + (-sinw*cosO - cosw*sinO*cosI)*yprime;
    const y = (cosw*sinO + sinw*cosO*cosI)*xprime + (-sinw*sinO + cosw*cosO*cosI)*yprime;
    const z = (sinw*sinI)*xprime + (cosw*sinI)*yprime;

    return {x,y,z};
  }

  function planetJPL(name, jd){
    const el = JPL_T2A[name];
    const T = (jd - 2451545.0) / 36525.0;
    const a = el.a0 + el.aDot * T;
    const e = el.e0 + el.eDot * T;
    const I = el.I0 + el.IDot * T;
    const L = el.L0 + el.LDot * T;
    const wbar = el.wbar0 + el.wbarDot * T;
    const Omega = el.Omega0 + el.OmegaDot * T;
    const omega = wbar - Omega;

    let M = L - wbar;
    if(JPL_T2B[name]){
      const t2b = JPL_T2B[name];
      M += (t2b.b * T * T) + (t2b.c * Math.cos(t2b.f * T * DEG)) + (t2b.s * Math.sin(t2b.f * T * DEG));
    }
    M = modAngleDeg(M);

    return posFromElements(a, e, I, Omega, omega, M);
  }

  function elementsJPL(name, jd){
    // PATCH [15] trails need the instantaneous ellipse parameters for sampling
    const el = JPL_T2A[name];
    const T = (jd - 2451545.0) / 36525.0;
    const a = el.a0 + el.aDot * T;
    const e = el.e0 + el.eDot * T;
    const I = el.I0 + el.IDot * T;
    const L = el.L0 + el.LDot * T;
    const wbar = el.wbar0 + el.wbarDot * T;
    const Omega = el.Omega0 + el.OmegaDot * T;
    const omega = wbar - Omega;

    let M = L - wbar;
    if(JPL_T2B[name]){
      const t2b = JPL_T2B[name];
      M += (t2b.b * T * T) + (t2b.c * Math.cos(t2b.f * T * DEG)) + (t2b.s * Math.sin(t2b.f * T * DEG));
    }
    M = modAngleDeg(M);
    return {a,e,I,Omega,omega,M};
  }

  function posFromKeplerBody(body, jd){
    const dt = jd - body.epoch_jd;
    const M = modAngleDeg(body.M0_deg + body.n * dt);
    return posFromElements(body.a, body.e, body.I, body.Omega, body.omega, M);
  }

  function elementsKeplerBody(body, jd){
    const dt = jd - body.epoch_jd;
    const M = modAngleDeg(body.M0_deg + body.n * dt);
    return {a:body.a,e:body.e,I:body.I,Omega:body.Omega,omega:body.omega,M};
  }

  // Pluto: internal consistency (kept)
  const PLUTO = makeKeplerBody({
    name: "Pluto",
    a: 39.4821,
    e: 0.24883,
    I: 17.14001,
    Omega: 110.30,
    omega: 113.76,
    epoch_jd: toJulianDay(1990,1,13),
    M0_deg: 0.0
  });

  // KYŪSEI (Planet Nine): canon
  const KYUSEI = (() => {
    const a = 520.0;
    const e = 0.35;
    const I = 20.0;
    const Omega = 88.0;
    const omega = 150.0;
    return makeKeplerBody({
      name: "KYŪSEI",
      a, e, I, Omega, omega,
      epoch_jd: toJulianDay(2210,1,1),
      M0_deg: 0.0
    });
  })();

  // Ceres / Vesta
  const CERES = makeKeplerBody({
    name: "CERES",
    a: 2.7675,
    e: 0.0758,
    I: 10.593,
    Omega: 80.305,
    omega: 73.597,
    epoch_jd: toJulianDay(2220,1,1),
    M0_deg: 0.0
  });

  const VESTA = makeKeplerBody({
    name: "VESTA",
    a: 2.361,
    e: 0.0887,
    I: 7.140,
    Omega: 103.851,
    omega: 150.987,
    epoch_jd: toJulianDay(2220,1,1),
    M0_deg: 180.0
  });

  // PATCH [14] add Eris + Haumea using JPL-derived infobox elements (epoch + a,e,i,Ω,ω,M)
  // Eris epoch JD 2461000.5; a 67.99; e 0.4370; i 43.86; Ω 36.02; ω 150.73; M 211.45
  const ERIS = makeKeplerBody({
    name: "ERIS",
    a: 67.99,
    e: 0.4370,
    I: 43.86,
    Omega: 36.02,
    omega: 150.73,
    epoch_jd: 2461000.5,
    M0_deg: 211.45
  });

  // Haumea epoch JD 2459200.5; a 43.116; e 0.19642; i 28.2137; Ω 122.167; ω 239.041; M 218.205
  const HAUMEA = makeKeplerBody({
    name: "HAUMEA",
    a: 43.116,
    e: 0.19642,
    I: 28.2137,
    Omega: 122.167,
    omega: 239.041,
    epoch_jd: 2459200.5,
    M0_deg: 218.205
  });

  // ---------------------------
  // 2) UI scaffold
  // ---------------------------
  const mount = document.getElementById("solar-map");
  if(!mount) return;

  // PATCH [11] swap input (selects) before output (readout)
  // PATCH [13] remove button words; keep symbols only
  mount.innerHTML = `
    <div class="map-frame">
      <div class="map-topline">
        <span class="date-click" id="map-date" title="Set date (YYYY-MM-DD)">DATE: 2225-06-06</span>
        <div class="map-controls">
          <span class="ctrlbtn" id="btn-prev">◀</span>
          <span class="ctrlbtn" id="btn-next">▶</span>
          <span class="ctrlbtn" id="btn-reset">⟲</span>
        </div>
      </div>

      <div class="map-svg-wrap" id="map-wrap">
        <svg id="solar-svg" viewBox="-36 -36 72 72" preserveAspectRatio="xMidYMid meet"></svg>

        <div class="map-zoompad" aria-label="Zoom controls">
          <div class="zbtn" id="btn-zoom-in">+</div>
          <div class="zbtn" id="btn-zoom-out">−</div>
        </div>
      </div>

      <div class="map-bottom">
        <div class="row">
          <div>
            <label for="sel-a">DEPART:</label>
            <select id="sel-a"></select>
          </div>
          <div>
            <label for="sel-b">ARRIVE:</label>
            <select id="sel-b"></select>
          </div>
        </div>
        <div class="hint">TIP: tap bodies to set DEPART then ARRIVE. pinch to zoom; drag to pan. mouse wheel zoom works on desktop. click DATE to set date.</div>
      </div>

      <div class="readout" id="readout">
        <div class="title">JOURNEY PLOTTED</div>
        <div class="line"><span class="k">DEPART</span><span class="v" id="ro-depart">EARTH</span></div>
        <div class="line"><span class="k">ARRIVE</span><span class="v" id="ro-arrive">JUPITER</span></div>
        <div style="height:6px;"></div>
        <div class="line"><span class="k">DISTANCE</span><span class="v" id="ro-dist">—</span></div>
        <div class="line"><span class="k">TIME</span><span class="v" id="ro-time">—</span></div>
        <div class="line"><span class="k">FUEL</span><span class="v" id="ro-fuel">—</span></div>
      </div>
    </div>
  `;

  const svg = document.getElementById("solar-svg");
  const wrap = document.getElementById("map-wrap");
  const dateEl = document.getElementById("map-date");

  const btnPrev = document.getElementById("btn-prev");
  const btnNext = document.getElementById("btn-next");
  const btnReset = document.getElementById("btn-reset");
  const btnZoomIn = document.getElementById("btn-zoom-in");
  const btnZoomOut = document.getElementById("btn-zoom-out");

  const selA = document.getElementById("sel-a");
  const selB = document.getElementById("sel-b");

  const roDepart = document.getElementById("ro-depart");
  const roArrive = document.getElementById("ro-arrive");
  const roDist = document.getElementById("ro-dist");
  const roTime = document.getElementById("ro-time");
  const roFuel = document.getElementById("ro-fuel");

  // ---------------------------
  // 3) Bodies
  // ---------------------------
  // PATCH [13] rename Lagrange points and treat as minor
  // PATCH [7] tighter trojan clouds; add Jupiter + Saturn L4/L5 clusters
  // PATCH [14] add Eris, Haumea
  const BODIES = [
    { key:"Mercury", label:"MERCURY", type:"jpl" },
    { key:"Venus",   label:"VENUS",   type:"jpl" },
    { key:"Earth",   label:"EARTH",   type:"jpl" },
    { key:"Mars",    label:"MARS",    type:"jpl" },

    { key:"Ceres",   label:"CERES",   type:"kepler", body:CERES, minor:true },
    { key:"Vesta",   label:"VESTA",   type:"kepler", body:VESTA, minor:true },

    { key:"Jupiter", label:"JUPITER", type:"jpl" },
    { key:"Ju-L4",   label:"Ju-L4",   type:"lagrange", parent:"Jupiter", lag:+60, cluster:"ju", minor:true },
    { key:"Ju-L5",   label:"Ju-L5",   type:"lagrange", parent:"Jupiter", lag:-60, cluster:"ju", minor:true },

    { key:"Saturn",  label:"SATURN",  type:"jpl" },
    { key:"Sa-L4",   label:"Sa-L4",   type:"lagrange", parent:"Saturn",  lag:+60, cluster:"sa", minor:true },
    { key:"Sa-L5",   label:"Sa-L5",   type:"lagrange", parent:"Saturn",  lag:-60, cluster:"sa", minor:true },

    { key:"Uranus",  label:"URANUS",  type:"jpl" },
    { key:"Neptune", label:"NEPTUNE", type:"jpl" },

    { key:"Pluto",   label:"PLUTO",   type:"kepler", body:PLUTO, minor:true },
    { key:"Haumea",  label:"HAUMEA",  type:"kepler", body:HAUMEA, minor:true },
    { key:"Eris",    label:"ERIS",    type:"kepler", body:ERIS, minor:true },

    { key:"Kyusei",  label:"KYŪSEI",  type:"kepler", body:KYUSEI }
  ];

  function fillSelect(sel){
    sel.innerHTML = "";
    for(const b of BODIES){
      const opt = document.createElement("option");
      opt.value = b.key;
      opt.textContent = b.label;
      sel.appendChild(opt);
    }
  }
  fillSelect(selA);
  fillSelect(selB);
  selA.value = "Earth";
  selB.value = "Mercury";

  // ---------------------------
  // 4) Time state
  // ---------------------------
  const START_JD = toJulianDay(2225, 6, 6);
  let dayOffset = 0;

  function currentJD(){ return START_JD + dayOffset; }

  function setDateLabel(){
    const jd = currentJD();
    const {y,m,d} = jdToYMD(jd);
    dateEl.textContent = `DATE: ${y}-${pad2(m)}-${pad2(d)}  (Δ ${dayOffset}d)`;
  }

  // ---------------------------
  // 5) SVG helpers + layers
  // ---------------------------
  function make(tag, attrs = {}){
    const el = document.createElementNS("http://www.w3.org/2000/svg", tag);
    for(const [k,v] of Object.entries(attrs)) el.setAttribute(k, String(v));
    return el;
  }
  function clearSVG(){
    while(svg.firstChild) svg.removeChild(svg.firstChild);
  }
  function setText(el, txt){
    while(el.firstChild) el.removeChild(el.firstChild);
    el.appendChild(document.createTextNode(txt));
  }

  // Create defs (glow filter)
  function ensureDefs(){
    const defs = make("defs");

    // PATCH [9][10] stronger + consistent glow for bodies/labels
    const filter = make("filter", {
      id: "tekugl",
      x: "-60%",
      y: "-60%",
      width: "220%",
      height: "220%"
    });

    const fe1 = make("feDropShadow", { dx:"0", dy:"0", stdDeviation:"1.05", "flood-color":"#EBFA7A", "flood-opacity":"0.38" });
    const fe2 = make("feDropShadow", { dx:"0", dy:"0", stdDeviation:"1.85", "flood-color":"#ffcc00", "flood-opacity":"0.22" });
    filter.appendChild(fe1);
    filter.appendChild(fe2);

    defs.appendChild(filter);
    svg.appendChild(defs);

    // PATCH [12] dotted patterns (true dot, not dash)
    const dp = make("pattern", { id:"dotpat", patternUnits:"userSpaceOnUse", width:"0.45", height:"0.45" });
    dp.appendChild(make("circle", { cx:"0.15", cy:"0.15", r:"0.07", fill:"rgba(255,204,0,0.8)" }));
    defs.appendChild(dp);
  }

  let gWorld, gTrails, gHUD, gOverlay;

  function buildLayers(){
    // world: belts + sun + fixed band text
    gWorld  = make("g", { id:"world" });

    // trails: behind bodies
    gTrails = make("g", { id:"trails" });

    // hud: bodies + labels + hit areas + journey line
    gHUD    = make("g", { id:"hud", filter:"url(#tekugl)" });

    // overlay: optional (unused, kept for future)
    gOverlay = make("g", { id:"overlay" });

    svg.appendChild(gWorld);
    svg.appendChild(gTrails);
    svg.appendChild(gHUD);
    svg.appendChild(gOverlay);
  }

  // ---------------------------
  // 6) ViewBox + interaction
  // ---------------------------
  const interaction = {
    pointers: new Map(),
    vb: { x:-36, y:-36, w:72, h:72 },
    baseW: 72,
    justGestured: false,
    gestureTimer: null
  };

  function setViewBox(vb){
    interaction.vb = vb;
    svg.setAttribute("viewBox", `${vb.x} ${vb.y} ${vb.w} ${vb.h}`);
    updateHUDScale();
    updateDeclutter();
  }

  function clientToWorld(clientX, clientY){
    const rect = svg.getBoundingClientRect();
    const nx = (clientX - rect.left) / rect.width;
    const ny = (clientY - rect.top) / rect.height;
    return {
      x: interaction.vb.x + nx * interaction.vb.w,
      y: interaction.vb.y + ny * interaction.vb.h
    };
  }

  function dist2(a,b){
    const dx = a.x - b.x, dy = a.y - b.y;
    return Math.sqrt(dx*dx + dy*dy);
  }

  function markGestured(){
    interaction.justGestured = true;
    if(interaction.gestureTimer) clearTimeout(interaction.gestureTimer);
    interaction.gestureTimer = setTimeout(() => interaction.justGestured = false, 180);
  }

  // Zoom helper (focus in world coords)
  function zoomAt(focusWorld, factor){
    const vb = interaction.vb;
    const nx = (focusWorld.x - vb.x) / vb.w;
    const ny = (focusWorld.y - vb.y) / vb.h;

    // PATCH [1] allow 3 more levels zoom-in (lower min width)
    const newW = clamp(vb.w * factor, 2.0, 160000);
    const newH = newW;

    const newX = focusWorld.x - nx * newW;
    const newY = focusWorld.y - ny * newH;

    setViewBox({ x:newX, y:newY, w:newW, h:newH });
    markGestured();
  }

  // PATCH [1] zoom buttons fixed on desktop:
  // - stop propagation so pointer system doesn't swallow click
  // - keep pointer-events enabled by CSS
  btnZoomIn.addEventListener("click", (e) => {
    e.preventDefault(); e.stopPropagation();
    const focus = { x: interaction.vb.x + interaction.vb.w/2, y: interaction.vb.y + interaction.vb.h/2 };
    zoomAt(focus, 0.80);
  });
  btnZoomOut.addEventListener("click", (e) => {
    e.preventDefault(); e.stopPropagation();
    const focus = { x: interaction.vb.x + interaction.vb.w/2, y: interaction.vb.y + interaction.vb.h/2 };
    zoomAt(focus, 1.22);
  });

  // Pointer gestures
  wrap.addEventListener("pointerdown", (e) => {
    // PATCH [1] don't steal pointerdown from zoom buttons
    const t = e.target;
    if(t && t.classList && t.classList.contains("zbtn")) return;

    wrap.setPointerCapture(e.pointerId);
    interaction.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
  });

  wrap.addEventListener("pointerup", (e) => {
    interaction.pointers.delete(e.pointerId);
  });

  wrap.addEventListener("pointercancel", (e) => {
    interaction.pointers.delete(e.pointerId);
  });

  wrap.addEventListener("pointermove", (e) => {
    if(!interaction.pointers.has(e.pointerId)) return;

    const prev = interaction.pointers.get(e.pointerId);
    const curr = { x: e.clientX, y: e.clientY };
    interaction.pointers.set(e.pointerId, curr);

    const pts = Array.from(interaction.pointers.values());

    if(pts.length === 1){
      const dx = curr.x - prev.x;
      const dy = curr.y - prev.y;

      const rect = svg.getBoundingClientRect();
      const wx = (dx / rect.width) * interaction.vb.w;
      const wy = (dy / rect.height) * interaction.vb.h;

      setViewBox({
        x: interaction.vb.x - wx,
        y: interaction.vb.y - wy,
        w: interaction.vb.w,
        h: interaction.vb.h
      });
      markGestured();
      return;
    }

    if(pts.length >= 2){
      const ids = Array.from(interaction.pointers.keys());
      const id1 = ids[0], id2 = ids[1];
      const p1 = interaction.pointers.get(id1);
      const p2 = interaction.pointers.get(id2);

      let b1 = p1, b2 = p2;
      let a1 = p1, a2 = p2;

      if(e.pointerId === id1){ b1 = prev; a1 = curr; }
      else if(e.pointerId === id2){ b2 = prev; a2 = curr; }

      const dBefore = dist2(b1,b2);
      const dAfter  = dist2(a1,a2);
      if(dBefore < 2 || dAfter < 2) return;

      const scale = dBefore / dAfter;
      const midClient = { x:(a1.x+a2.x)/2, y:(a1.y+a2.y)/2 };
      const midWorld = clientToWorld(midClient.x, midClient.y);

      zoomAt(midWorld, scale);
    }
  });

  // Wheel zoom (desktop)
  wrap.addEventListener("wheel", (e) => {
    e.preventDefault();
    const delta = Math.sign(e.deltaY);
    const factor = delta > 0 ? 1.14 : 0.88;
    const focus = clientToWorld(e.clientX, e.clientY);
    zoomAt(focus, factor);
  }, { passive:false });

  // ---------------------------
  // 7) Body positions
  // ---------------------------
  function bodyDef(key){
    return BODIES.find(b => b.key === key) || null;
  }

  function bodyPos(key, jd){
    const b = bodyDef(key);
    if(!b) return {x:0,y:0,z:0};

    if(b.type === "jpl") return planetJPL(b.key, jd);
    if(b.type === "kepler") return posFromKeplerBody(b.body, jd);
    if(b.type === "lagrange") return lagrangePos(b.parent, b.lag, jd);
    return {x:0,y:0,z:0};
  }

  function bodyElements(key, jd){
    const b = bodyDef(key);
    if(!b) return null;
    if(b.type === "jpl") return elementsJPL(b.key, jd);
    if(b.type === "kepler") return elementsKeplerBody(b.body, jd);
    return null;
  }

  function computeDistanceAU(aKey, bKey, jd){
    const A = bodyPos(aKey, jd);
    const B = bodyPos(bKey, jd);
    const dx = A.x - B.x;
    const dy = A.y - B.y;
    const dz = A.z - B.z;
    return Math.sqrt(dx*dx + dy*dy + dz*dz);
  }

  function lagrangePos(parentName, degOffset, jd){
    const p = planetJPL(parentName, jd);
    const ang = degOffset * DEG;
    const x = p.x * Math.cos(ang) - p.y * Math.sin(ang);
    const y = p.x * Math.sin(ang) + p.y * Math.cos(ang);
    return { x, y, z: p.z };
  }

  // Deterministic "random" for cluster dot cloud
  function hash01(i){
    const s = Math.sin(i * 999.123 + 0.12345) * 43758.5453123;
    return s - Math.floor(s);
  }

  // ---------------------------
  // 8) Screen-constant HUD scaling + declutter
  // ---------------------------
  // PATCH [6] increase standard label size (about 2×) and keep constant at all zooms:
  // fix: DO NOT clamp hudScale too high at deep zoom-in (was causing growth).
  let hudScale = 1;

  function updateHUDScale(){
    hudScale = interaction.vb.w / interaction.baseW;

    // PATCH [6] allow deep zoom-in without hitting a clamp that makes things grow
    hudScale = clamp(hudScale, 0.02, 40.0);

    const dots = gHUD ? gHUD.querySelectorAll("[data-dot]") : [];
    dots.forEach(el => {
      const base = Number(el.getAttribute("data-dot-base") || "0.16");
      el.setAttribute("r", (base * hudScale).toString());
    });

    const texts = gHUD ? gHUD.querySelectorAll("[data-label]") : [];
    texts.forEach(el => {
      const baseFS = Number(el.getAttribute("data-fs-base") || "1.20");
      el.setAttribute("font-size", (baseFS * hudScale).toString());
    });

    const coord = gHUD ? gHUD.querySelectorAll("[data-coord]") : [];
    coord.forEach(el => {
      const baseFS = Number(el.getAttribute("data-fs-base") || "0.46");
      el.setAttribute("font-size", (baseFS * hudScale).toString());
    });

    const hits = gHUD ? gHUD.querySelectorAll("[data-hit]") : [];
    hits.forEach(el => {
      const base = Number(el.getAttribute("data-hit-base") || "0.55");
      el.setAttribute("r", (base * hudScale).toString());
    });

    // Band labels remain in WORLD (they scale with map). No hudScale updates on them. (per your earlier design)
  }

  // PATCH [5] small-body labels disappear more aggressively on zoom-out
  const declutter = {
    coordsHideAt: 70,
    smallHideAt: 95,
    innerHideAt: 160,
    lagrangeHideAt: 85
  };

  function isWorldPointInView(p){
    const vb = interaction.vb;
    return (p.x >= vb.x && p.x <= vb.x + vb.w && p.y >= vb.y && p.y <= vb.y + vb.h);
  }

  function updateDeclutter(){
    const w = interaction.vb.w;
    const coordsOn = w < declutter.coordsHideAt;
    const smallOn  = w < declutter.smallHideAt;
    const innerOn  = w < declutter.innerHideAt;
    const lagOn    = w < declutter.lagrangeHideAt;

    const forceKeys = new Set([selA.value, selB.value]); // PATCH [12] always show selected labels (if body in view)

    const labelNodes = gHUD ? gHUD.querySelectorAll("[data-label-group]") : [];
    labelNodes.forEach(g => {
      const key = g.getAttribute("data-key") || "";
      const cls = g.getAttribute("data-class") || "major";

      let show = true;
      if(cls === "small" && !smallOn) show = false;
      if(cls === "inner" && !innerOn) show = false;
      if(cls === "lag"   && !lagOn)   show = false;
      if(cls === "major") show = true;

      // PATCH [12] if selected AND the body is in view, keep visible
      if(forceKeys.has(key)){
        const bp = bodyPos(key, currentJD());
        if(isWorldPointInView(bp)) show = true;
      }

      g.style.opacity = show ? "1" : "0";

      const coords = g.querySelectorAll("[data-coord]");
      coords.forEach(t => t.style.opacity = coordsOn ? "0.78" : "0");
    });
  }

  // ---------------------------
  // 9) Draw world (sun, belts)
  // ---------------------------
  const SUN_R = 0.55; // used for overlap avoidance too

  function drawSun(){
    gWorld.appendChild(make("circle", {
      cx:0, cy:0, r:0.22,
      fill:"#ffcc00",
      opacity:"0.85",
      filter:"url(#tekugl)" // PATCH [9] glow on bodies (sun too)
    }));
    gWorld.appendChild(make("circle", {
      cx:0, cy:0, r:SUN_R,
      fill:"none",
      stroke:"rgba(235,250,122,0.18)",
      "stroke-width":"0.08",
      opacity:"0.55",
      filter:"url(#tekugl)"
    }));
  }

  // PATCH [5] remove line borders from WILD WASTE / SECOND CROWN / OORT
  function drawAnnulus(rIn, rOut, opacity){
    const ring = make("path", {
      d: annulusPath(rIn, rOut),
      fill: `rgba(255,204,0,${opacity})`,
      "fill-rule": "evenodd",
      stroke: "none",
      "stroke-width": "0",
      opacity: 1
    });
    gWorld.appendChild(ring);
  }

  function annulusPath(rIn, rOut){
    const o = circlePath(0,0,rOut);
    const i = circlePath(0,0,rIn);
    return o + " " + i;
  }

  function circlePath(cx,cy,r){
    return [
      `M ${cx + r} ${cy}`,
      `A ${r} ${r} 0 1 0 ${cx - r} ${cy}`,
      `A ${r} ${r} 0 1 0 ${cx + r} ${cy}`,
      "Z"
    ].join(" ");
  }

  // PATCH [7][8] band label color + size adjustments
  function ensureBandText(){
    // second crown + wild waste as world text (behind all labels)
    // WILD WASTE smaller (0.25 its earlier intention)
    const ww = make("text", {
      x: 2.55 * Math.cos(315*DEG),
      y: 2.55 * Math.sin(315*DEG),
      fill: "#54522C",
      opacity: "0.30",
      "font-family":"monospace",
      "font-weight":"1000",
      "letter-spacing":"0.22em",
      "font-size":"0.55",   // reduced
      "text-anchor":"middle"
    });
    setText(ww, "WILD WASTE");
    gWorld.appendChild(ww);

    const sc = make("text", {
      x: 47.0 * Math.cos(135*DEG),
      y: 47.0 * Math.sin(135*DEG),
      fill: "#54522C",
      opacity: "0.34",
      "font-family":"monospace",
      "font-weight":"1000",
      "letter-spacing":"0.22em",
      "font-size":"2.2",
      "text-anchor":"middle"
    });
    setText(sc, "SECOND CROWN");
    gWorld.appendChild(sc);

    // PATCH [11] Oort Cloud band + label (accurate scale band; huge, mostly off at normal view)
    const oc = make("text", {
      x: 8000 * Math.cos(45*DEG),
      y: 8000 * Math.sin(45*DEG),
      fill: "#54522C",
      opacity: "0.16",
      "font-family":"monospace",
      "font-weight":"1000",
      "letter-spacing":"0.28em",
      "font-size":"260",
      "text-anchor":"middle"
    });
    setText(oc, "OORT CLOUD");
    gWorld.appendChild(oc);
  }

  // ---------------------------
  // 10) Trails (PATCH [15])
  // ---------------------------
  function drawTrailForBody(key, jd, isMinor){
    const el = bodyElements(key, jd);
    if(!el) return;

    // no trails for lagrange objects (caller ensures)
    const N = 120;                 // number of segments
    const step = 360 / N;          // degrees between samples
    const fadeK = isMinor ? 2.0 : 1.0; // minor bodies fade faster (double reduction)

    // sample "behind" the current mean anomaly
    for(let i=0;i<N;i++){
      const M1 = modAngleDeg(el.M - i*step);
      const M2 = modAngleDeg(el.M - (i+1)*step);

      const p1 = posFromElements(el.a, el.e, el.I, el.Omega, el.omega, M1);
      const p2 = posFromElements(el.a, el.e, el.I, el.Omega, el.omega, M2);

      const t = i / N;
      const op = Math.exp(-fadeK * t * 3.2) * 0.55;

      const seg = make("line", {
        x1: p1.x, y1: p1.y,
        x2: p2.x, y2: p2.y,
        stroke: "rgba(255,204,0,1)",
        "stroke-opacity": op.toFixed(4),
        "stroke-width": (0.06).toString(),
        "stroke-linecap":"round",
        filter:"url(#tekugl)"
      });
      gTrails.appendChild(seg);
    }
  }

  // ---------------------------
  // 11) Labels: magnetic placement w/ overlap avoidance (PATCH [4][10][14])
  // ---------------------------
  function approxTextBoxWorld(x, y, text, fs, lines){
    // crude monospace estimate in world-units:
    // width ~ chars * fs * 0.62 ; height ~ lines * fs * 1.15
    const w = Math.max(1, text.length) * fs * 0.62;
    const h = Math.max(1, lines) * fs * 1.15;
    return { x, y: y - h, w, h }; // treat (x,y) as baseline left; bbox above baseline
  }

  function intersects(a,b){
    return !(a.x + a.w < b.x || b.x + b.w < a.x || a.y + a.h < b.y || b.y + b.h < a.y);
  }

  function sunBox(){
    return { x:-SUN_R, y:-SUN_R, w:SUN_R*2, h:SUN_R*2 };
  }

  function clampLabelIntoView(box){
    const vb = interaction.vb;
    let dx = 0, dy = 0;
    if(box.x < vb.x) dx = vb.x - box.x;
    if(box.x + box.w > vb.x + vb.w) dx = (vb.x + vb.w) - (box.x + box.w);
    if(box.y < vb.y) dy = vb.y - box.y;
    if(box.y + box.h > vb.y + vb.h) dy = (vb.y + vb.h) - (box.y + box.h);
    return { dx, dy };
  }

  function pickLabelAnchor(pos, name, fsName, fsCoord, clsKey, placed){
    // PATCH [10] magnetism stability: offsets scale with hudScale + text size
    const basePad = 0.30 * hudScale;
    const offsets = [
      {dx:+(basePad), dy:-(basePad)},   // NE
      {dx:+(basePad), dy:+(basePad)},   // SE
      {dx:-(basePad), dy:-(basePad)},   // NW
      {dx:-(basePad), dy:+(basePad)},   // SW
      {dx:+(basePad*1.9), dy:0},        // E
      {dx:-(basePad*1.9), dy:0},        // W
      {dx:0, dy:-(basePad*1.9)},        // N
      {dx:0, dy:+(basePad*1.9)}         // S
    ];

    // compute approximate boxes (name + 3 coords lines)
    const lines = 1 + 3;
    const fs = fsName;
    const sunB = sunBox();

    // marker avoid box
    const m = { x: pos.x - 0.35*hudScale, y: pos.y - 0.35*hudScale, w: 0.70*hudScale, h: 0.70*hudScale };

    let best = null;
    let bestScore = 1e9;

    for(const o of offsets){
      const x = pos.x + o.dx + (0.25*hudScale);
      const y = pos.y + o.dy - (0.10*hudScale);

      const bb = approxTextBoxWorld(x, y, name + " x000 y000 z000", fs, lines);

      // clamp so label stays in view when body is in view
      const adj = clampLabelIntoView(bb);
      const bb2 = { x: bb.x + adj.dx, y: bb.y + adj.dy, w: bb.w, h: bb.h };

      // avoid sun, marker, other labels
      if(intersects(bb2, sunB)) continue;
      if(intersects(bb2, m)) continue;

      let collide = false;
      for(const p of placed){
        if(intersects(bb2, p)) { collide = true; break; }
      }
      if(collide) continue;

      // score prefers minimal movement from default offset
      const score = Math.abs(o.dx) + Math.abs(o.dy) + Math.abs(adj.dx)*2 + Math.abs(adj.dy)*2;
      if(score < bestScore){
        bestScore = score;
        best = { x: x + adj.dx, y: y + adj.dy, box: bb2 };
      }
    }

    // fallback: still clamp into view; accept overlap if necessary
    if(!best){
      const x = pos.x + basePad + (0.25*hudScale);
      const y = pos.y - basePad - (0.10*hudScale);
      const bb = approxTextBoxWorld(x, y, name + " x000 y000 z000", fs, lines);
      const adj = clampLabelIntoView(bb);
      const bb2 = { x: bb.x + adj.dx, y: bb.y + adj.dy, w: bb.w, h: bb.h };
      best = { x: x + adj.dx, y: y + adj.dy, box: bb2 };
    }

    placed.push(best.box);
    return best;
  }

  // ---------------------------
  // 12) Draw bodies (HUD) - dots + labels + coords
  // ---------------------------
  function drawBody(b, pos, placedBoxes){
    const cls =
      (b.type === "lagrange") ? "lag" :
      (b.key === "Mercury" || b.key === "Venus" || b.key === "Earth" || b.key === "Mars") ? "inner" :
      (b.minor) ? "small" :
      "major";

    // base radii
    const baseR =
      b.key === "Jupiter" ? 0.28 :
      b.key === "Saturn"  ? 0.26 :
      b.key === "Uranus"  ? 0.24 :
      b.key === "Neptune" ? 0.24 :
      b.key === "Earth"   ? 0.16 :
      b.key === "Venus"   ? 0.16 :
      b.key === "Mars"    ? 0.14 :
      b.key === "Mercury" ? 0.13 :
      (b.minor ? 0.11 : 0.14);

    const hitBase = Math.max(0.75, baseR * 6);

    // dot
    const dot = make("circle", {
      cx: pos.x, cy: pos.y,
      r: (baseR * hudScale),
      fill: "#ffcc00",
      opacity: "0.85",
      "data-dot": "1",
      "data-dot-base": String(baseR),
      filter: "url(#tekugl)" // PATCH [9][10] glow on bodies
    });
    gHUD.appendChild(dot);

    // label group
    const g = make("g", {
      "data-label-group":"1",
      "data-class": cls,
      "data-key": b.key
    });

    // PATCH [6] increase standard size of all labels; coords smaller
    // PATCH [15] Ju-L4 and minor bodies slightly smaller
    const nameBase = (cls === "small" || cls === "lag") ? 1.05 : 1.25;
    const coordBase = (cls === "small" || cls === "lag") ? 0.40 : 0.46;

    // PATCH [14] fix line spacing scaling bug: compute from font size
    const fsName = nameBase * hudScale;
    const fsCoord = coordBase * hudScale;
    const lineH = fsCoord * 1.25;

    const anch = pickLabelAnchor(pos, b.label, fsName, fsCoord, cls, placedBoxes);

    const nameText = make("text", {
      x: anch.x,
      y: anch.y,
      fill: "#ffcc00",
      "font-family":"monospace",
      "font-weight":"1000",
      "letter-spacing":"0.10em",
      "font-size": fsName,
      "data-label":"1",
      "data-fs-base": String(nameBase),
      filter: "url(#tekugl)"
    });
    setText(nameText, b.label);
    g.appendChild(nameText);

    const coordStyle = {
      fill: "#ffcc00",
      "font-family":"monospace",
      "font-weight":"800",
      "letter-spacing":"0.08em",
      opacity:"0.78"
    };

    // PATCH [3] remove "AU" from in-map coordinates
    const cx = make("text", {
      x: anch.x, y: anch.y + (fsName*0.95) + (lineH*0.05),
      "font-size": fsCoord,
      "data-coord":"1",
      "data-fs-base": String(coordBase),
      ...coordStyle
    });
    setText(cx, `x ${fmtSign(pos.x, 3)}`);
    g.appendChild(cx);

    const cy = make("text", {
      x: anch.x, y: anch.y + (fsName*0.95) + (lineH*1.05),
      "font-size": fsCoord,
      "data-coord":"1",
      "data-fs-base": String(coordBase),
      ...coordStyle
    });
    setText(cy, `y ${fmtSign(pos.y, 3)}`);
    g.appendChild(cy);

    const cz = make("text", {
      x: anch.x, y: anch.y + (fsName*0.95) + (lineH*2.05),
      "font-size": fsCoord,
      "data-coord":"1",
      "data-fs-base": String(coordBase),
      ...coordStyle
    });
    setText(cz, `z ${fmtSign(pos.z, 3)}`);
    g.appendChild(cz);

    gHUD.appendChild(g);

    // hit area
    const hit = make("circle", {
      cx: pos.x, cy: pos.y,
      r: (hitBase * hudScale),
      fill: "transparent",
      "data-hit": b.key,
      "data-hit-base": String(hitBase)
    });
    gHUD.appendChild(hit);
  }

  // PATCH [7] tighter cluster fuzz for lagrange points (tiny, near parent)
  function drawClusterAround(pos, seed, tightnessAU){
    const nDots = 18;
    for(let i=0;i<nDots;i++){
      const a = (hash01(i + seed) * 2*Math.PI);
      const r = (tightnessAU * (0.35 + hash01(i+seed+100) * 0.65));
      const ox = Math.cos(a) * r;
      const oy = Math.sin(a) * r;

      const p = { x: pos.x + ox, y: pos.y + oy };

      const dot = make("circle", {
        cx: p.x, cy: p.y,
        r: (0.055 * hudScale),
        fill: "#ffcc00",
        opacity: "0.55",
        filter:"url(#tekugl)"
      });
      gHUD.appendChild(dot);
    }
  }

  // ---------------------------
  // 13) Journey line (PATCH [2][17])
  // ---------------------------
  function drawJourneyLine(jd){
    const aKey = selA.value;
    const bKey = selB.value;
    const A = bodyPos(aKey, jd);
    const B = bodyPos(bKey, jd);

    // PATCH [2] true dotted not dashed: use round cap + tiny dasharray
    const line = make("line", {
      x1: A.x, y1: A.y,
      x2: B.x, y2: B.y,
      stroke: "#ffcc00",
      "stroke-width": (0.10 * hudScale).toString(),
      "stroke-linecap":"round",
      "stroke-dasharray": `${(0.06*hudScale).toString()} ${(0.32*hudScale).toString()}`,
      opacity: "0.38",
      filter:"url(#tekugl)"
    });
    gHUD.appendChild(line);
  }

  // ---------------------------
  // 14) Render
  // ---------------------------
  function updateReadout(){
    const jd = currentJD();
    const aKey = selA.value;
    const bKey = selB.value;

    const aDef = bodyDef(aKey);
    const bDef = bodyDef(bKey);

    roDepart.textContent = aDef ? aDef.label : aKey;
    roArrive.textContent = bDef ? bDef.label : bKey;

    const dAU = computeDistanceAU(aKey, bKey, jd);

    // 2% of c in AU/day
    const AU_PER_DAY = 3.4629;
    const tDays = dAU / AU_PER_DAY;

    const fuel = 38.0 + tDays;

    roDist.textContent = `${fmtAU1(dAU)} AU`;
    roTime.textContent = `${fmtAU1(tDays)} d`;
    roFuel.textContent = `${fmtAU1(fuel)} ā`;
  }

  // Click-to-select A then B
  let clickStage = 0;
  svg.addEventListener("click", (e) => {
    if(interaction.justGestured) return;

    const target = e.target;
    if(!(target instanceof SVGElement)) return;

    const key = target.getAttribute("data-hit");
    if(!key) return;

    if(!bodyDef(key)) return;

    if(clickStage % 2 === 0) selA.value = key;
    else selB.value = key;

    clickStage++;
    updateReadout();
    render(); // keep selected labels forced-visible logic correct
  });

  selA.addEventListener("change", () => { updateReadout(); render(); });
  selB.addEventListener("change", () => { updateReadout(); render(); });

  function render(){
    const jd = currentJD();

    clearSVG();
    ensureDefs();
    buildLayers();

    // PATCH [2] remove circular orbit rings (were misleading)

    // Belts
    drawAnnulus(2.10, 3.30, 0.05);   // WILD WASTE
    drawAnnulus(30.0, 50.0, 0.03);   // SECOND CROWN

    // PATCH [11] Oort Cloud band (approx: 2,000–100,000 AU)
    drawAnnulus(2000.0, 100000.0, 0.007);

    ensureBandText();
    drawSun();

    // PATCH [15] trails for all moving bodies except lagrange objects
    for(const b of BODIES){
      if(b.type === "lagrange") continue;
      const isMinor = !!b.minor;
      drawTrailForBody(b.key, jd, isMinor);
    }

    // bodies + labels
    const placed = [];
    for(const b of BODIES){
      const pos = bodyPos(b.key, jd);

      // lagrange clusters
      if(b.type === "lagrange"){
        // PATCH [7] tighter fuzz around L points
        drawClusterAround(pos, b.key === "Ju-L4" ? 500 : b.key === "Ju-L5" ? 600 : b.key === "Sa-L4" ? 700 : 800, 0.13);
      }

      drawBody(b, pos, placed);
    }

    // PATCH [17] journey line dotted
    drawJourneyLine(jd);

    setDateLabel();
    updateHUDScale();
    updateDeclutter();
    updateReadout();
  }

  // ---------------------------
  // 15) Controls
  // ---------------------------
  function stepDays(n){
    dayOffset += n;
    dayOffset = clamp(dayOffset, -365250, 365250);
    render();
  }

  btnPrev.addEventListener("click", () => stepDays(-1));
  btnNext.addEventListener("click", () => stepDays(+1));
  btnReset.addEventListener("click", () => { dayOffset = 0; render(); });

  // Date input
  dateEl.addEventListener("click", () => {
    const jd = currentJD();
    const {y,m,d} = jdToYMD(jd);
    const current = `${y}-${pad2(m)}-${pad2(d)}`;
    const s = prompt("Set date (YYYY-MM-DD):", current);
    if(s === null) return;

    const parsed = parseYMD(s);
    if(!parsed){
      alert("Invalid date. Use YYYY-MM-DD.");
      return;
    }

    const newJD = toJulianDay(parsed.y, parsed.m, parsed.d);
    dayOffset = Math.round(newJD - START_JD);
    dayOffset = clamp(dayOffset, -365250, 365250);
    render();
  });

  // Initial viewBox
  setViewBox({ x:-36, y:-36, w:72, h:72 });

  // Initial render
  render();

})();
</script>

</body>
</html>
