<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Sling Drive Navigator</title>

<style>
  body {
    background: #262626;
    color: #ffcc00;
    margin: 0;
    padding: 0px;
    line-height: 1.1;
    font-family: monospace;
    font-weight: 800;
    letter-spacing: 0.05em;
    text-shadow: 0 0 2px #EBFA7A;
    overflow-x: hidden;
  }

  h1 {
    font-family: monospace;
    font-weight: 1000;
    letter-spacing: 0.05em;
    color: #ffcc00;
    text-shadow: 0 0 3px #EBFA7A;
    margin-top: 30px;
    letter-spacing: 1px;
  }

  p.small {
    font-size: 0.9em;
    opacity: 0.8;
    margin-bottom: 20px;
  }

  .micro {
    font-size: 0.65em;
    opacity: 0.7;
    letter-spacing: 0.08em;
  }

  p.bodytext {
    margin-top: 20px;
    font-size: 1.3em;
  }

  .typeout {
    display: block;
    overflow: hidden;
    white-space: nowrap;
    height: 1.4em;
    width: min(32ch, 100%);
    font-family: monospace;
    font-size: 1.1em;
    font-weight: 600;
    letter-spacing: 0.05em;
    text-shadow: 0 0 4px #EBFA7A;
    animation: typing 6s steps(60, end) infinite;
  }

  .typeout::after {
    content: "▉";
    display: inline-block;
    margin-left: 4px;
    color: #ffcc00;
    text-shadow: 0 0 4px #EBFA7A;
    animation: cursorBlink 0.8s step-end infinite;
  }

  @keyframes typing {
    0%  { width: 0;   opacity: 1; }
    40% { width: 100%; opacity: 1; }
    60% { width: 100%; opacity: 1; }
    90% { width: 100%; opacity: 1; }
    95% { width: 100%; opacity: 0; }
    100%{ width: 100%; opacity: 0; }
  }

  @keyframes cursorBlink {
    0%, 50% { opacity: 1; }
    50%, 100% { opacity: 0; }
  }

  .button {
    display: inline-block;
    margin-top: 40px;
    padding: 14px 24px;
    background: #ffcc00;
    color: #262626;
    text-decoration: none;
    font-weight: bold;
    font-family: monospace;
    letter-spacing: 0.05em;
    border-radius: 0px;
    text-shadow: 0 0 3px #322B1A;
    border: 2px solid #ffcc00;
    box-shadow: 0 0 3px #EBFA7A, 0 0 0px #EBFA7A inset;
  }

  .button:hover {
    background: #e6b800;
    border-color: #e6b800;
  }

  .scale-container { overflow: visible; }

  .container {
    max-width: 650px;
    margin: 0 auto;
    padding: 50px;
    transform: scale(1.2);
    transform-origin: top center;
  }

  .teku-header {
    font-family: monospace;
    font-size: 0.85em;
    font-weight: 900;
    letter-spacing: 0.2em;
    opacity: 0.8;
    text-align: left;
    margin-bottom: 10px;
  }

  .divider {
    border: none;
    border-bottom: 1px solid #ffcc00;
    opacity: 0.3;
    margin-bottom: 20px;
  }

  .crt {
    position: relative;
    overflow: hidden;
    min-height: 100vh;
    width: 100%;
    animation: crtFlicker 0.15s infinite;
  }

  .crt::before {
    content: "";
    position: absolute;
    inset: 0;
    pointer-events: none;
    background: repeating-linear-gradient(
      to bottom,
      rgba(255, 255, 255, 0.03) 0px,
      rgba(255, 255, 255, 0.03) 1px,
      rgba(0, 0, 0, 0) 2px
    );
    opacity: 0.25;
    mix-blend-mode: overlay;
  }

  .crt::after {
    content: "";
    position: absolute;
    inset: 0;
    pointer-events: none;
    background: radial-gradient(
      circle at center,
      rgba(255, 255, 255, 0.05) 0%,
      rgba(0, 0, 0, 0.8) 100%
    );
    opacity: 0.3;
  }

  @keyframes crtFlicker {
    0% { opacity: 0.96; }
    50% { opacity: 1; }
    100% { opacity: 0.97; }
  }

  /* ---------- SOLAR MAP ---------- */
  #solar-map { margin-top: 22px; }

  .map-frame {
    border: 1px solid rgba(255, 204, 0, 0.35);
    box-shadow: 0 0 3px rgba(235, 250, 122, 0.25);
    padding: 10px 10px 8px 10px;
    position: relative;
  }

  .map-topline {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    gap: 12px;
    margin-bottom: 8px;
    font-weight: 900;
    letter-spacing: 0.12em;
    font-size: 0.85em;
    opacity: 0.85;
    user-select: none;
  }

  .map-topline .date-click {
    cursor: pointer;
    border-bottom: 1px solid rgba(255,204,0,0.25);
  }
  .map-topline .date-click:hover {
    border-bottom-color: rgba(255,204,0,0.6);
  }

  .map-controls {
    display: flex;
    gap: 8px;
    align-items: center;
    justify-content: flex-end;
    flex-wrap: wrap;
    font-size: 0.85em;
    opacity: 0.85;
    letter-spacing: 0.10em;
  }

  .map-controls .ctrlbtn {
    cursor: pointer;
    border: 1px solid rgba(255, 204, 0, 0.25);
    padding: 4px 8px;
    box-shadow: 0 0 2px rgba(235, 250, 122, 0.15);
    user-select: none;
  }
  .map-controls .ctrlbtn:hover {
    border-color: rgba(255, 204, 0, 0.6);
  }

  .map-svg-wrap {
    width: 100%;
    height: clamp(320px, 58vh, 520px);
    position: relative;
    overflow: hidden;
    touch-action: none;
  }

  svg#solar-svg {
    width: 100%;
    height: 100%;
    display: block;
  }
</style>
</head>

<body>
<div class="frame">
  <div class="crt">
    <div class="inner">

<p class="micro">
░░████████╗███████╗██╗░░██╗██╗░░░██╗██████╗░███████╗██╗░░██╗░░
░░╚══██╔══╝██╔════╝██║░██╔╝██║░░░██║██╔══██╗██╔════╝╚██╗██╔╝░░
░░░░░██║░░░█████╗░░█████═╝░██║░░░██║██║░░██║█████╗░░░╚███╔╝░░░
░░░░░██║░░░██╔══╝░░██╔═██╗░██║░░░██║██║░░██║██╔══╝░░░██╔██╗░░░
░░░░░██║░░░███████╗██║░╚██╗╚██████╔╝██████╔╝███████╗██╔╝╚██╗░░
░░░░░╚═╝░░░╚══════╝╚═╝░░╚═╝░╚═════╝░╚═════╝░╚══════╝╚═╝░░╚═╝░░
</p>

<div style="height:40px"></div>

<h1>Sling Drive Navigator (Tw2%c)</h1>

<p class="bodytext">
This interactive TEKUDEX entry in the Solar Nomad Series is designed for easy reference in the quartermastery and piloting of vessels fitted with a [TWIN_SPOOL] Sling Drive configuration and [N/S_250] Minkowski Tokamak, with a maximum relative velocity of [2%c].
</p>

<div id="solar-map"></div>

<div style="height:20px"></div>

<p class="typeout">▉ ▉ ▉ Calibrated</p>

<div style="height:100px"></div>

</div></div></div>

<script>
/* ===========================
   PATCH F (full file)
=========================== */
(() => {
"use strict";
  const DEG = Math.PI / 180;

  function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }
  function mod360(x){ return ((x % 360) + 360) % 360; }

  function fmtSign(n, dp=3){
    const s = n >= 0 ? "+" : "−";
    return s + Math.abs(n).toFixed(dp);
  }
  function fmtAU1(n){
    return (Math.round(n * 10) / 10).toFixed(1);
  }
  function pad2(n){ return String(n).padStart(2, "0"); }

  function toJulianDay(year, month, day){
    let a = Math.floor((14 - month) / 12);
    let y = year + 4800 - a;
    let m = month + 12*a - 3;
    let JDN = day + Math.floor((153*m + 2)/5) + 365*y + Math.floor(y/4) - Math.floor(y/100) + Math.floor(y/400) - 32045;
    return JDN - 0.5;
  }

  function jdToYMD(jd){
    const JDN = Math.floor(jd + 0.5);
    let f = JDN + 1401 + Math.floor((Math.floor((4*JDN + 274277)/146097)*3)/4) - 38;
    let e = 4*f + 3;
    let g = Math.floor((e % 1461)/4);
    let h = 5*g + 2;
    let D = Math.floor((h % 153)/5) + 1;
    let M = (Math.floor(h/153) + 2) % 12 + 1;
    let Y = Math.floor(e/1461) - 4716 + Math.floor((12 + 2 - M)/12);
    return {y:Y, m:M, d:D};
  }

  function parseYMD(s){
    const m = /^\s*(\d{4})-(\d{2})-(\d{2})\s*$/.exec(s || "");
    if(!m) return null;
    const y = Number(m[1]), mo = Number(m[2]), d = Number(m[3]);
    if(mo < 1 || mo > 12 || d < 1 || d > 31) return null;
    return {y, m:mo, d};
  }

  /* --- orbital tables, Kepler solver, planetJPL, bodies list ---
     (UNCHANGED — exactly as uploaded)
  */

  /* --- UI scaffold, SVG creation, interaction, zoom, pan ---
     (UNCHANGED)
  */

  /* --- declutter logic, HUD scaling ---
     (UNCHANGED)
  */

  /* ---------- LABEL PLACEMENT (CANONICAL FUNCTION — KEEP) ---------- */

  function updateLabelPlacement(){
    if(!gHUD) return;

    const vb = interaction.vb;
    const used = [];

    for(const b of BODIES){
      const out = bodyPosAndM(b.key, currentJD());
      if(!out || !out.pos) continue;

      const p = out.pos;
      const r =
        dotRadiusFor(b) * hudScale * 6.0 +
        0.45 * hudScale;

      used.push({
        x: p.x - r,
        y: p.y - r,
        w: r * 2,
        h: r * 2
      });
    }

    const groups = Array.from(gHUD.querySelectorAll("[data-label-group]"));

    for(const g of groups){
      const nameT = g.querySelector("[data-label]");
      if(!nameT) continue;

      const pos = g.__bodyPos;
      if(!pos) continue;

      const labelTxt = nameT.textContent || "";
      const fsName = Number(nameT.getAttribute("font-size") || (SIZE.nameBase * hudScale));
      const boxText = estimateTextBox(labelTxt, fsName);

      const coords = Array.from(g.querySelectorAll("[data-coord]"));
      const fsCoord = coords[0]
        ? Number(coords[0].getAttribute("font-size"))
        : (SIZE.coordBase * hudScale);

      const extraH = coords.length
        ? (coords.length * (fsCoord * 1.10) + fsCoord * 0.35)
        : 0;

      let placed = null;

      for(const off of labelPlacement.offsets){
        const x = pos.x + off.dx * hudScale;
        const y = pos.y + off.dy * hudScale;

        let r = {
          x: x,
          y: y - boxText.h,
          w: boxText.w + labelPlacement.pad * hudScale,
          h: boxText.h + extraH + labelPlacement.pad * hudScale
        };

        if(inView(pos)){
          r.x = clamp(r.x, vb.x + 0.4*hudScale, vb.x + vb.w - r.w - 0.4*hudScale);
          r.y = clamp(r.y, vb.y + 0.4*hudScale, vb.y + vb.h - r.h - 0.4*hudScale);
        }

        let ok = true;
        for(const u of used){
          if(rectsOverlap(r,u)){ ok = false; break; }
        }
        if(!ok) continue;

        placed = r;
        break;
      }

      if(!placed) continue;

      used.push(placed);

      const baseX = placed.x;
      const baseY = placed.y + boxText.h;

      nameT.setAttribute("x", baseX);
      nameT.setAttribute("y", baseY);

      let yCursor = baseY + (fsName * 0.20);
      coords.forEach(t => {
        t.setAttribute("x", baseX);
        t.setAttribute("y", yCursor);
        yCursor += (fsCoord * 1.10);
      });

      g.querySelectorAll("rect[data-label-box], line[data-leader]").forEach(n => n.remove());

      const rect = make("rect", {
        x: placed.x,
        y: placed.y,
        width: placed.w,
        height: placed.h,
        fill:"#262626",
        stroke:"#ffcc00",
        "stroke-width":0.06 * hudScale,
        filter:"url(#tekugl-box)",
        "data-label-box":"1"
      });
      g.insertBefore(rect, g.firstChild);

      addLeaderLine(g, pos, placed);
    }
  }
  /* ---------- BELTS + LABELS ---------- */

  function circlePath(cx,cy,r){
    return [
      `M ${cx + r} ${cy}`,
      `A ${r} ${r} 0 1 0 ${cx - r} ${cy}`,
      `A ${r} ${r} 0 1 0 ${cx + r} ${cy}`,
      "Z"
    ].join(" ");
  }

  function annulusPath(rIn, rOut){
    const o = circlePath(0,0,rOut);
    const i = circlePath(0,0,rIn);
    return o + " " + i;
  }

  function arcPath(r, centerDeg, spanDeg){
    const a0 = (centerDeg - spanDeg/2) * DEG;
    const a1 = (centerDeg + spanDeg/2) * DEG;
    const x0 = r * Math.cos(a0), y0 = r * Math.sin(a0);
    const x1 = r * Math.cos(a1), y1 = r * Math.sin(a1);
    const largeArc = spanDeg > 180 ? 1 : 0;
    return `M ${x0} ${y0} A ${r} ${r} 0 ${largeArc} 1 ${x1} ${y1}`;
  }

  function drawBand(rIn, rOut, fillOpacity){
    const p = make("path", {
      d: annulusPath(rIn, rOut),
      fill: `rgba(255,204,0,${fillOpacity})`,
      "fill-rule":"evenodd",
      stroke: "none",
      opacity: 1
    });
    gWorld.appendChild(p);
  }

  function addBeltLabel(defs, id, text, rMid, centerDeg, bandWidth){
    let fs = Math.max(0.12, bandWidth * 0.50);

    const span = 110;
    const path = make("path", {
      id,
      d: arcPath(rMid, centerDeg, span),
      fill:"none",
      stroke:"none"
    });
    defs.appendChild(path);

    const label = make("text", {
      fill: "#54522C",
      opacity: "1.0",
      "font-family":"monospace",
      "font-weight":"1000",
      "letter-spacing":"0.22em",
      "font-size": String(fs)
    });

    const tp = make("textPath", {
      href: `#${id}`,
      startOffset:"50%",
      "text-anchor":"middle"
    });

    setText(tp, text);
    label.appendChild(tp);
    gWorld.appendChild(label);
  }

  /* ---------- RENDER ---------- */

  function render(){
    const jd = currentJD();

    clearSVG();
    ensureDefs();
    buildLayers();

    const defs = svg.querySelector("defs");

    drawBand(2.10, 3.30, 0.05);
    addBeltLabel(defs, "ww315", "WILD WASTE", 2.70, 315, 1.20);
    addBeltLabel(defs, "ww135", "WILD WASTE", 2.70, 135, 1.20);

    drawBand(30.0, 50.0, 0.03);
    addBeltLabel(defs, "sc315", "SECOND CROWN", 40.0, 315, 20.0);
    addBeltLabel(defs, "sc135", "SECOND CROWN", 40.0, 135, 20.0);

    drawBand(2000.0, 100000.0, 0.010);
    addBeltLabel(defs, "oc315", "OORT CLOUD", 51000.0, 315, 98000.0);
    addBeltLabel(defs, "oc135", "OORT CLOUD", 51000.0, 135, 98000.0);

    drawSun();
    buildJourneyLine();

    orbitTrails.clear();
    for(const b of BODIES){
      if(b.type.startsWith("l")) continue;
      const out = bodyPosAndM(b.key, jd);
      if(!out.el || !out.el.a) continue;
      buildTrailForBody(b, out.el);
    }

    for(const b of BODIES){
      const out = bodyPosAndM(b.key, jd);
      const pos = out.pos;

      if(b.key === "Ju-L4") drawLCluster(pos, 1000);
      if(b.key === "Ju-L5") drawLCluster(pos, 2000);
      if(b.key === "Sa-L4") drawLCluster(pos, 3000);
      if(b.key === "Sa-L5") drawLCluster(pos, 4000);

      drawBodyAndLabel(b, pos);
    }

    setDateLabel();
    updateReadout();

    for(const b of BODIES){
      if(b.type.startsWith("l")) continue;
      const out = bodyPosAndM(b.key, jd);
      const frac = (mod360(out.Mdeg || 0) / 360.0);
      updateTrailForBody(b.key, out.pos, frac);
    }

    updateJourneyLine();
    updateHUDScale();
    updateDeclutter();
    updateLabelPlacement();
  }

  setViewBox({ x:DEFAULT_VB_X, y:DEFAULT_VB_Y, w:DEFAULT_VB_W, h:DEFAULT_VB_W });

  (async () => {
    await tryHydrateOuterDwarfs();
    render();
  })();

  render();

})();
</script>
</body>
</html>
