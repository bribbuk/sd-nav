<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Sling Drive Navigator</title>

<style>
  body {
    background: #262626;
    color: #ffcc00;
    margin: 0;
    padding: 0px;
    line-height: 1.1;
    font-family: monospace;
    font-weight: 800;
    letter-spacing: 0.05em;
    text-shadow: 0 0 2px #EBFA7A;
    overflow-x: hidden;
  }

  h1 {
    font-family: monospace;
    font-weight: 1000;
    letter-spacing: 0.05em;
    color: #ffcc00;
    text-shadow: 0 0 3px #EBFA7A;
    margin-top: 30px;
    letter-spacing: 1px;
  }

  p.small {
    font-size: 0.9em;
    opacity: 0.8;
    margin-bottom: 20px;
  }

  .micro {
    font-size: 0.65em;
    opacity: 0.7;
    letter-spacing: 0.08em;
  }

  p.bodytext {
    margin-top: 20px;
    font-size: 1.3em;
  }

  .typeout {
    display: block;
    overflow: hidden;
    white-space: nowrap;
    height: 1.4em;
    width: min(32ch, 100%);
    font-family: monospace;
    font-size: 1.1em;
    font-weight: 600;
    letter-spacing: 0.05em;
    text-shadow: 0 0 4px #EBFA7A;
    animation: typing 6s steps(60, end) infinite;
  }

  .typeout::after {
    content: "▉";
    display: inline-block;
    margin-left: 4px;
    color: #ffcc00;
    text-shadow: 0 0 4px #EBFA7A;
    animation: cursorBlink 0.8s step-end infinite;
  }

  @keyframes typing {
    0%  { width: 0;   opacity: 1; }
    40% { width: 100%; opacity: 1; }
    60% { width: 100%; opacity: 1; }
    90% { width: 100%; opacity: 1; }
    95% { width: 100%; opacity: 0; }
    100%{ width: 100%; opacity: 0; }
  }

  @keyframes cursorBlink {
    0%, 50% { opacity: 1; }
    50%, 100% { opacity: 0; }
  }

  .button {
    display: inline-block;
    margin-top: 40px;
    padding: 14px 24px;
    background: #ffcc00;
    color: #262626;
    text-decoration: none;
    font-weight: bold;
    font-family: monospace;
    letter-spacing: 0.05em;
    border-radius: 0px;
    text-shadow: 0 0 3px #322B1A;
    border: 2px solid #ffcc00;
    box-shadow: 0 0 3px #EBFA7A, 0 0 0px #EBFA7A inset;
  }

  .button:hover {
    background: #e6b800;
    border-color: #e6b800;
  }

  .scale-container { overflow: visible; }

  .container {
    max-width: 650px;
    margin: 0 auto;
    padding: 50px;
    transform: scale(1.2);
    transform-origin: top center;
  }

  .teku-header {
    font-family: monospace;
    font-size: 0.85em;
    font-weight: 900;
    letter-spacing: 0.2em;
    opacity: 0.8;
    text-align: left;
    margin-bottom: 10px;
  }

  .divider {
    border: none;
    border-bottom: 1px solid #ffcc00;
    opacity: 0.3;
    margin-bottom: 20px;
  }

  .crt {
    position: relative;
    overflow: hidden;
    min-height: 100vh;
    width: 100%;
    animation: crtFlicker 0.15s infinite;
  }

  .crt::before {
    content: "";
    position: absolute;
    inset: 0;
    pointer-events: none;
    background: repeating-linear-gradient(
      to bottom,
      rgba(255, 255, 255, 0.03) 0px,
      rgba(255, 255, 255, 0.03) 1px,
      rgba(0, 0, 0, 0) 2px
    );
    opacity: 0.25;
    mix-blend-mode: overlay;
  }

  .crt::after {
    content: "";
    position: absolute;
    inset: 0;
    pointer-events: none;
    background: radial-gradient(
      circle at center,
      rgba(255, 255, 255, 0.05) 0%,
      rgba(0, 0, 0, 0.8) 100%
    );
    opacity: 0.3;
  }

  @keyframes crtFlicker {
    0% { opacity: 0.96; }
    50% { opacity: 1; }
    100% { opacity: 0.97; }
  }

  /* ---------- SOLAR MAP ---------- */
  #solar-map { margin-top: 22px; }

  .map-frame {
    border: 1px solid rgba(255, 204, 0, 0.35);
    box-shadow: 0 0 3px rgba(235, 250, 122, 0.25);
    padding: 10px 10px 8px 10px;
    position: relative;
  }

  .map-topline {
    display: flex;
    justify-content: space-between;
    align-items: baseline;
    gap: 12px;
    margin-bottom: 8px;
    font-weight: 900;
    letter-spacing: 0.12em;
    font-size: 0.85em;
    opacity: 0.85;
    user-select: none;
  }

  .map-topline .date-click {
    cursor: pointer;
    border-bottom: 1px solid rgba(255,204,0,0.25);
  }
  .map-topline .date-click:hover {
    border-bottom-color: rgba(255,204,0,0.6);
  }

  .map-controls {
    display: flex;
    gap: 8px;
    align-items: center;
    justify-content: flex-end;
    flex-wrap: wrap;
    font-size: 0.85em;
    opacity: 0.85;
    letter-spacing: 0.10em;
  }

  .map-controls .ctrlbtn {
    cursor: pointer;
    border: 1px solid rgba(255, 204, 0, 0.25);
    padding: 4px 8px;
    box-shadow: 0 0 2px rgba(235, 250, 122, 0.15);
    user-select: none;
  }
  .map-controls .ctrlbtn:hover {
    border-color: rgba(255, 204, 0, 0.6);
  }

  .map-svg-wrap {
    width: 100%;
    height: clamp(320px, 58vh, 520px);
    position: relative;
    overflow: hidden;
    touch-action: none;
  filter:
    drop-shadow(0 0 1.5px rgba(235,250,122,0.22))
    drop-shadow(0 0 4px rgba(255,204,0,0.14))
    drop-shadow(0 0 10px rgba(255,204,0,0.06));
  }

  svg#solar-svg {
    width: 100%;
    height: 100%;
    display: block;
  }

  /* bottom-right zoom buttons */
  .zoom-corner {
    position: absolute;
    right: 10px;
    bottom: 10px;
    display: flex;
    gap: 8px;
    z-index: 20;
    user-select: none;
    font-size: 0.9em;
    opacity: 0.92;
    letter-spacing: 0.10em;
    pointer-events: auto;
  }
  .zoom-corner .ctrlbtn {
    pointer-events: auto;
    cursor: pointer;
    border: 1px solid rgba(255, 204, 0, 0.25);
    padding: 4px 10px;
    box-shadow: 0 0 2px rgba(235, 250, 122, 0.15);
    background: rgba(38,38,38,0.35);
    backdrop-filter: blur(1px);
  }
  .zoom-corner .ctrlbtn:hover { border-color: rgba(255,204,0,0.6); }

  .readout {
    margin-top: 10px;
    padding: 10px 10px 8px 10px;
    border-top: 1px solid rgba(255,204,0,0.18);
    border-bottom: 1px solid rgba(255,204,0,0.18);
    letter-spacing: 0.10em;
    font-size: 0.95em;
    opacity: 0.95;
    text-shadow: 0 0 4px rgba(235,250,122,0.35);
  }

  .readout .title {
    font-weight: 1000;
    opacity: 0.95;
    margin-bottom: 6px;
  }

  .readout .line {
    display: flex;
    justify-content: space-between;
    gap: 12px;
    margin: 2px 0;
    flex-wrap: wrap;
  }

  .readout .k {
    opacity: 0.85;
    min-width: 10ch;
  }

  .readout .v {
    font-weight: 1000;
  }

  .map-bottom {
    margin-top: 10px;
    padding-top: 8px;
    font-size: 0.85em;
    letter-spacing: 0.10em;
    opacity: 0.90;
    display: grid;
    grid-template-columns: 1fr;
    gap: 6px;
  }

  .map-bottom .row {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    align-items: baseline;
    justify-content: space-between;
  }

  .map-bottom label {
    opacity: 0.9;
    margin-right: 6px;
  }

  .map-bottom select {
    background: transparent;
    color: #ffcc00;
    border: 1px solid rgba(255,204,0,0.25);
    font-family: monospace;
    font-weight: 800;
    padding: 4px 6px;
    letter-spacing: 0.08em;
    outline: none;
    text-shadow: 0 0 4px rgba(235,250,122,0.35);
  }

  .map-bottom select option {
    background: #262626;
    color: #ffcc00;
    text-shadow: 0 0 4px rgba(235,250,122,0.35);
  }

  .hint {
    opacity: 0.75;
    font-size: 0.8em;
    letter-spacing: 0.10em;
  }

  /* ---------- MOBILE UI OPTIMISATION (≤600px) ---------- */
  @media (max-width: 600px) {
    body {
      font-size: 8px;
      padding: 0;
      margin: 0;
    }

    .teku-header {
      font-size: 1.3em;
      letter-spacing: 0.15em;
    }

    p.small { font-size: 1.0em; }

    h1 {
      font-size: 2em;
      line-height: 1.3;
    }

    p.bodytext { font-size: 1.3em; }

    .typeout { font-size: 1.3em; }

    .button {
      font-size: 1.4em;
      padding: 16px 24px;
    }

    .container {
      transform: none;
      padding: 20px;
    }

    .map-topline { font-size: 1.0em; }
    .map-controls { font-size: 1.0em; }
    .map-bottom { font-size: 1.0em; }
    .readout { font-size: 1.05em; }
    .zoom-corner { font-size: 1.05em; right: 8px; bottom: 8px; }
  }
</style>
</head>

<body>
  <div class="scale-container">
    <div class="crt">
      <div class="container">

        <p class="teku-header">UNREGISTERED TEKU SLATE</p>
        <hr class="divider">
        <p class="small">TEKUDEX Default Guide "EID-SN4SD/Nav/Tw2%c"</p>

        <p class="micro">
░░████████╗███████╗██╗░░██╗██╗░░░██╗██████╗░███████╗██╗░░██╗░░
░░╚══██╔══╝██╔════╝██║░██╔╝██║░░░██║██╔══██╗██╔════╝╚██╗██╔╝░░
░░░░░██║░░░█████╗░░█████═╝░██║░░░██║██║░░██║█████╗░░░╚███╔╝░░░
░░░░░██║░░░██╔══╝░░██╔═██╗░██║░░░██║██║░░██║██╔══╝░░░██╔██╗░░░
░░░░░██║░░░███████╗██║░╚██╗╚██████╔╝██████╔╝███████╗██╔╝╚██╗░░
░░░░░╚═╝░░░╚══════╝╚═╝░░╚═╝░╚═════╝░╚═════╝░╚══════╝╚═╝░░╚═╝░░
        </p>

        <div style="height: 40px;"></div>

        <h1>Sling Drive Navigator (Tw2%c)</h1>

        <p class="small">
          This interactive TEKUDEX entry in the Solar Nomad Series is designed for easy reference in the quartermastery and piloting of vessels fitted with a [TWIN_SPOOL] Sling Drive configuration and [N/S_250] Minkowski Tokamak, with a maximum relative velocity of [2%c].
        </p>

        <div id="solar-map"></div>

        <div style="height: 20px;"></div>

        <p class="typeout">▉ ▉ ▉ Fully Calibrated </p>

        <div style="height: 20px;"></div>

        <h1>[TWIN_SPOOL] Specification</h1>

        <p class="small">
          In a Twin Spool engine configuration, 2 spools are jarred concurrently (2 × 100ā = 200ā total). <br> <br>
          
The tradeoff is simple: double consumption in exchange for higher v[x,y,z] cap (%c) or greater field range (N/S, ft). <br>

        </p>
        
          <p class="bodytext">
          
YOUR SHIP BURNS: <br> <br>

S-unS (Min. Sling-Unsling): <br>
            38ā (instead of 19ā) <br> <br>

Travel (Sustained): <br>
            2ā/day (instd of 1ā/day) <br> <br>

Example (Actual%c Subj to Spec): <br>
            DEPART: Mercury »»» ARRIVE: Pluto; ~16 days @ 1.4%c; nil interruption(s): <br>
(38ā × 1) [S-unS] + (16 × 2ā) [Daily] = 70ā [Gross] <br>

          </p>

        <p class="small">
            <br>
          The Twin Spool configuration is typically deployed on large, commercial vessels (passenger and freight) and in military corvette-class designs. Twin Spooled firmware has occasionally been ID'd in unregulated Wild Waste racing events. 
          <br> <br>
          TEKUDEX advises EXTREME CAUTION near any courier-class or smaller ships operating a Multi-Spool retrofit. 
          
        </p>
        
        <div style="height: 100px;"></div>

      </div>
    </div>
  </div>

<script>
/* ===========================
   PATCH F (full file)
   Fixes:
   - Zoom buttons work on desktop (stop pointer-capture conflicts)
   - Default view more zoomed-in; clamp extreme zoom-in
   - No “pale circle” between Mercury/Venus (removed sun outer ring)
   - Belt labels: no glow, no borders, fixed “vector” sizing tied to belt width, 315/135, #54522C, opacity 1
   - Journey line: dotted, thinner, glow, stroke scales screen-constant with zoom
   - Trails: line up with planets + real fade gradient; thinner
   - Oort Cloud band restored
   - No label overlap with other labels or Sun; selected labels forced visible if body in view
=========================== */
(() => {
  "use strict";

  // ---------------------------
  // 0) Utilities
  // ---------------------------
  const DEG = Math.PI / 180;

  function clamp(x, a, b){ return Math.max(a, Math.min(b, x)); }
  function mod360(x){ return ((x % 360) + 360) % 360; }

// Catmull–Rom → Cubic Bézier (passes through ALL points)
function catmullRomToBezier(p0, p1, p2, p3, tension = 0.5){
  const t = tension;

  const c1x = p1.x + (p2.x - p0.x) * t / 6;
  const c1y = p1.y + (p2.y - p0.y) * t / 6;

  const c2x = p2.x - (p3.x - p1.x) * t / 6;
  const c2y = p2.y - (p3.y - p1.y) * t / 6;

  return `C ${c1x} ${c1y} ${c2x} ${c2y} ${p2.x} ${p2.y}`;
}

  function catmullRomSpline(points, tension = 0.6){
  let d = `M ${points[0].x} ${points[0].y}`;
  for(let i = 0; i < points.length - 1; i++){
    const p0 = points[i - 1] || points[i];
    const p1 = points[i];
    const p2 = points[i + 1];
    const p3 = points[i + 2] || p2;

    const t = tension;

    const c1x = p1.x + (p2.x - p0.x) * t / 6;
    const c1y = p1.y + (p2.y - p0.y) * t / 6;

    const c2x = p2.x - (p3.x - p1.x) * t / 6;
    const c2y = p2.y - (p3.y - p1.y) * t / 6;

    d += ` C ${c1x} ${c1y}, ${c2x} ${c2y}, ${p2.x} ${p2.y}`;
  }
  return d;
}

  
  function fmtSign(n, dp=3){
    const s = n >= 0 ? "+" : "−";
    return s + Math.abs(n).toFixed(dp);
  }
  function fmtAU1(n){
    return (Math.round(n * 10) / 10).toFixed(1);
  }
  function pad2(n){ return String(n).padStart(2, "0"); }

  function toJulianDay(year, month, day){
    let a = Math.floor((14 - month) / 12);
    let y = year + 4800 - a;
    let m = month + 12*a - 3;
    let JDN = day + Math.floor((153*m + 2)/5) + 365*y + Math.floor(y/4) - Math.floor(y/100) + Math.floor(y/400) - 32045;
    return JDN - 0.5;
  }

  function jdToYMD(jd){
    const JDN = Math.floor(jd + 0.5);
    let f = JDN + 1401 + Math.floor((Math.floor((4*JDN + 274277)/146097)*3)/4) - 38;
    let e = 4*f + 3;
    let g = Math.floor((e % 1461)/4);
    let h = 5*g + 2;
    let D = Math.floor((h % 153)/5) + 1;
    let M = (Math.floor(h/153) + 2) % 12 + 1;
    let Y = Math.floor(e/1461) - 4716 + Math.floor((12 + 2 - M)/12);
    return {y:Y, m:M, d:D};
  }

  function parseYMD(s){
    const m = /^\s*(\d{4})-(\d{2})-(\d{2})\s*$/.exec(s || "");
    if(!m) return null;
    const y = Number(m[1]), mo = Number(m[2]), d = Number(m[3]);
    if(mo < 1 || mo > 12 || d < 1 || d > 31) return null;
    return {y, m:mo, d};
  }

  // ---------------------------
  // 1) Orbital model (planets: JPL approx)
  // ---------------------------
  const JPL_T2A = {
    Mercury:  { a0:0.38709843, aDot:0.00000000, e0:0.20563661, eDot:0.00002123, I0:7.00559432, IDot:-0.00590158, L0:252.25166724, LDot:149472.67486623, wbar0:77.45771895, wbarDot:0.15940013, Omega0:48.33961819, OmegaDot:-0.12214182 },
    Venus:    { a0:0.72332102, aDot:-0.00000026, e0:0.00676399, eDot:-0.00005107, I0:3.39777545, IDot:0.00043494, L0:181.97970850, LDot:58517.81560260, wbar0:131.76755713, wbarDot:0.05679648, Omega0:76.67261496, OmegaDot:-0.27274174 },
    Earth:    { a0:1.00000018, aDot:-0.00000003, e0:0.01673163, eDot:-0.00003661, I0:-0.00054346, IDot:-0.01337178, L0:100.46691572, LDot:35999.37306329, wbar0:102.93005885, wbarDot:0.31795260, Omega0:-5.11260389, OmegaDot:-0.24123856 },
    Mars:     { a0:1.52371243, aDot:0.00000097, e0:0.09336511, eDot:0.00009149, I0:1.85181869, IDot:-0.00724757, L0:-4.56813164, LDot:19140.29934243, wbar0:-23.91744784, wbarDot:0.45223625, Omega0:49.71320984, OmegaDot:-0.26852431 },
    Jupiter:  { a0:5.20248019, aDot:-0.00002864, e0:0.04853590, eDot:0.00018026, I0:1.29861416, IDot:-0.00322699, L0:34.33479152, LDot:3034.90371757, wbar0:14.27495244, wbarDot:0.18199196, Omega0:100.29282654, OmegaDot:0.13024619 },
    Saturn:   { a0:9.54149883, aDot:-0.00003065, e0:0.05550825, eDot:-0.00032044, I0:2.49424102, IDot:0.00451969, L0:50.07571329, LDot:1222.11494724, wbar0:92.86136063, wbarDot:0.54179478, Omega0:113.63998702, OmegaDot:-0.25015002 },
    Uranus:   { a0:19.18797948, aDot:-0.00020455, e0:0.04685740, eDot:-0.00001550, I0:0.77298127, IDot:-0.00180155, L0:314.20276625, LDot:428.49512595, wbar0:172.43404441, wbarDot:0.09266985, Omega0:73.96250215, OmegaDot:0.05739699 },
    Neptune:  { a0:30.06952752, aDot:0.00006447, e0:0.00895439, eDot:0.00000818, I0:1.77005520, IDot:0.00022400, L0:304.22289287, LDot:218.46515314, wbar0:46.68158724, wbarDot:0.01009938, Omega0:131.78635853, OmegaDot:-0.00606302 }
  };

  const JPL_T2B = {
    Jupiter: { b:-0.00012452, c:0.06064060, s:-0.35635438, f:38.35125000 },
    Saturn:  { b: 0.00025899, c:-0.13434469, s: 0.87320147, f:38.35125000 },
    Uranus:  { b: 0.00058331, c:-0.97731848, s: 0.17689245, f: 7.67025000 },
    Neptune: { b:-0.00041348, c:0.68346318, s:-0.10162547, f: 7.67025000 }
  };

  function solveKeplerE(Mdeg, e){
    let M = (Mdeg * DEG);
    let E = M + e * Math.sin(M);
    for(let i=0;i<18;i++){
      let f = E - e*Math.sin(E) - M;
      let fp = 1 - e*Math.cos(E);
      let dE = -f / fp;
      E += dE;
      if(Math.abs(dE) < 1e-12) break;
    }
    return E;
  }

  function posFromElements(a, e, Ideg, OmegaDeg, omegaDeg, Mdeg){
    const I = Ideg*DEG, Om = OmegaDeg*DEG, w = omegaDeg*DEG;
    const E = solveKeplerE(Mdeg, e);

    const xprime = a * (Math.cos(E) - e);
    const yprime = a * Math.sqrt(1 - e*e) * Math.sin(E);

    const cosw = Math.cos(w),  sinw = Math.sin(w);
    const cosO = Math.cos(Om), sinO = Math.sin(Om);
    const cosI = Math.cos(I),  sinI = Math.sin(I);

    const x = (cosw*cosO - sinw*sinO*cosI)*xprime + (-sinw*cosO - cosw*sinO*cosI)*yprime;
    const y = (cosw*sinO + sinw*cosO*cosI)*xprime + (-sinw*sinO + cosw*cosO*cosI)*yprime;
    const z = (sinw*sinI)*xprime + (cosw*sinI)*yprime;

    return {x,y,z};
  }

  function planetJPL(name, jd){
    const el = JPL_T2A[name];
    const T = (jd - 2451545.0) / 36525.0;
    const a = el.a0 + el.aDot * T;
    const e = el.e0 + el.eDot * T;
    const I = el.I0 + el.IDot * T;
    const L = el.L0 + el.LDot * T;
    const wbar = el.wbar0 + el.wbarDot * T;
    const Omega = el.Omega0 + el.OmegaDot * T;
    const omega = wbar - Omega;

    let M = L - wbar;
    if(JPL_T2B[name]){
      const t2b = JPL_T2B[name];
      M += (t2b.b * T * T) + (t2b.c * Math.cos(t2b.f * T * DEG)) + (t2b.s * Math.sin(t2b.f * T * DEG));
    }
    M = mod360(M);

    return { pos: posFromElements(a, e, I, Omega, omega, M), el: {a,e,I,Omega,omega,M} };
  }

  function makeKeplerBody({name, a, e, I, Omega, omega, epoch_jd, M0_deg, n_deg_per_day, isMinor=false}){
    return { name, a, e, I, Omega, omega, epoch_jd, M0_deg, n: n_deg_per_day, isMinor: !!isMinor };
  }

  function posFromKeplerBody(body, jd){
    const M = mod360(body.M0_deg + body.n * (jd - body.epoch_jd));
    return { pos: posFromElements(body.a, body.e, body.I, body.Omega, body.omega, M), Mdeg: M };
  }

   // ---------------------------
  // 2) UI scaffold
  // ---------------------------
  const mount = document.getElementById("solar-map");
  if(!mount) return;


  const WORLD_SCALE = 100;

const DEFAULT_VB_W = 4 * WORLD_SCALE;
const DEFAULT_VB_X = -2 * WORLD_SCALE + (0.7 * WORLD_SCALE);
const DEFAULT_VB_Y = -2 * WORLD_SCALE;
// The scale at which HUD/text/glow are considered "native"
const WORKING_VB_W = 4 * WORLD_SCALE;
  
  mount.innerHTML = `
    <div class="map-frame">
      <div class="map-topline">
        <span class="date-click" id="map-date" title="Set date (YYYY-MM-DD)">DATE: 2225-06-06</span>
        <div class="map-controls">
          <span class="ctrlbtn" id="btn-prev">◀</span>
          <span class="ctrlbtn" id="btn-next">▶</span>
          <span class="ctrlbtn" id="btn-reset">RESET</span>
        </div>
      </div>

      <div class="map-svg-wrap" id="map-wrap">
        <svg id="solar-svg" viewBox="${DEFAULT_VB_X} ${DEFAULT_VB_Y} ${DEFAULT_VB_W} ${DEFAULT_VB_W}" preserveAspectRatio="xMidYMid meet"></svg>

        <div class="zoom-corner">
          <span class="ctrlbtn" id="btn-zoom-in">+</span>
          <span class="ctrlbtn" id="btn-zoom-out">−</span>
        </div>
      </div>

      <div class="map-bottom">
        <div class="row">
          <div>
            <label for="sel-a">DEPART:</label>
            <select id="sel-a"></select>
          </div>
          <div>
            <label for="sel-b">ARRIVE:</label>
            <select id="sel-b"></select>
          </div>
        </div>
      </div>

      <div class="readout" id="readout">
        <div class="title">JOURNEY PLOTTED</div>
        <div class="line"><span class="k">DEPART</span><span class="v" id="ro-depart">—</span></div>
        <div class="line"><span class="k">ARRIVE</span><span class="v" id="ro-arrive">—</span></div>
        <div style="height:6px;"></div>
        <div class="line"><span class="k">DISTANCE</span><span class="v" id="ro-dist">—</span></div>
        <div class="line"><span class="k">TIME</span><span class="v" id="ro-time">—</span></div>
        <div class="line"><span class="k">FUEL</span><span class="v" id="ro-fuel">—</span></div>
      </div>

      <div class="hint">SPONSORED TIP: <i>Long-range reliability improves when non-essential systems are modular and replaceable.</i> <br> 
      » MAERSK HELIOS, Together All The Way.  
      </div>
  `;

  const svg = document.getElementById("solar-svg");
  const wrap = document.getElementById("map-wrap");
  const dateEl = document.getElementById("map-date");

  const btnPrev = document.getElementById("btn-prev");
  const btnNext = document.getElementById("btn-next");
  const btnReset = document.getElementById("btn-reset");
  const btnZoomIn = document.getElementById("btn-zoom-in");
  const btnZoomOut = document.getElementById("btn-zoom-out");

  const selA = document.getElementById("sel-a");
  const selB = document.getElementById("sel-b");

  const roDepart = document.getElementById("ro-depart");
  const roArrive = document.getElementById("ro-arrive");
  const roDist = document.getElementById("ro-dist");
  const roTime = document.getElementById("ro-time");
  const roFuel = document.getElementById("ro-fuel");

  // Stop zoom buttons being “eaten” by pointer-capture/pan logic (desktop bug fix)
  ["pointerdown","pointerup","pointermove","click","wheel"].forEach(evt => {
    btnZoomIn.addEventListener(evt, (e)=>{ e.stopPropagation(); }, { passive: evt==="wheel" ? false : true });
    btnZoomOut.addEventListener(evt, (e)=>{ e.stopPropagation(); }, { passive: evt==="wheel" ? false : true });
  });

  // ---------------------------
  // 3) Bodies (L-points + dwarfs)
  // ---------------------------
  const START_JD = toJulianDay(2225, 6, 6);
  let dayOffset = 0;
  function currentJD(){ return START_JD + dayOffset; }

  // Canon/near-canon Kepler placeholders (Eris/Haumea hydrated from JPL Horizons below)
  const PLUTO = makeKeplerBody({
    name:"PLUTO", a:39.4821, e:0.24883, I:17.14001, Omega:110.30, omega:113.76,
    epoch_jd: START_JD, M0_deg: 0, n_deg_per_day: 0.003973966, isMinor:true
  });

  const KYUSEI = (() => {
    const a = 520.0, e = 0.35, I = 20.0, Omega = 88.0, omega = 150.0;
    const P_years = Math.sqrt(a*a*a);
    const P_days  = P_years * 365.25;
    const n = 360.0 / P_days;
    return makeKeplerBody({ name:"KYŪSEI", a,e,I,Omega,omega, epoch_jd: START_JD, M0_deg:0, n_deg_per_day:n, isMinor:false });
  })();

  const CERES = (() => {
    const P = 1680.2;
    return makeKeplerBody({ name:"CERES", a:2.7675, e:0.0758, I:10.593, Omega:80.305, omega:73.597, epoch_jd: START_JD, M0_deg:0, n_deg_per_day:360.0/P, isMinor:true });
  })();
  const VESTA = (() => {
    const P = 1325.6;
    return makeKeplerBody({ name:"VESTA", a:2.361, e:0.0887, I:7.140, Omega:103.851, omega:150.987, epoch_jd: START_JD, M0_deg:180, n_deg_per_day:360.0/P, isMinor:true });
  })();

  let ERIS = makeKeplerBody({ name:"ERIS", a:67.996, e:0.436965, I:44.04, Omega:35.95, omega:151.80, epoch_jd: START_JD, M0_deg:0, n_deg_per_day:0.0005, isMinor:true });
  let HAUMEA = makeKeplerBody({ name:"HAUMEA", a:43.218, e:0.191, I:28.19, Omega:121.9, omega:240.6, epoch_jd: START_JD, M0_deg:0, n_deg_per_day:0.0011, isMinor:true });

  function rotateXY(p, angRad){
    return { x: p.x*Math.cos(angRad) - p.y*Math.sin(angRad), y: p.x*Math.sin(angRad) + p.y*Math.cos(angRad), z: p.z };
  }

  function jovianL4Pos(jd){ return rotateXY(planetJPL("Jupiter", jd).pos,  60*DEG); }
  function jovianL5Pos(jd){ return rotateXY(planetJPL("Jupiter", jd).pos, -60*DEG); }
  function saturnL4Pos(jd){ return rotateXY(planetJPL("Saturn",  jd).pos,  60*DEG); }
  function saturnL5Pos(jd){ return rotateXY(planetJPL("Saturn",  jd).pos, -60*DEG); }

  const BODIES = [
    { key:"Mercury",  label:"MERCURY", type:"jpl",    class:"inner" },
    { key:"Venus",    label:"VENUS",   type:"jpl",    class:"inner" },
    { key:"Earth",    label:"EARTH",   type:"jpl",    class:"inner" },
    { key:"Mars",     label:"MARS",    type:"jpl",    class:"inner" },

    { key:"Ceres",    label:"CERES",   type:"kepler", body:()=>CERES,  class:"small" },
    { key:"Vesta",    label:"VESTA",   type:"kepler", body:()=>VESTA,  class:"small" },

    { key:"Jupiter",  label:"JUPITER", type:"jpl",    class:"major" },
    { key:"Ju-L4",    label:"Ju-L4",   type:"l4j",    class:"smallL" },
    { key:"Ju-L5",    label:"Ju-L5",   type:"l5j",    class:"smallL" },

    { key:"Saturn",   label:"SATURN",  type:"jpl",    class:"major" },
    { key:"Sa-L4",    label:"Sa-L4",   type:"l4s",    class:"smallL" },
    { key:"Sa-L5",    label:"Sa-L5",   type:"l5s",    class:"smallL" },

    { key:"Uranus",   label:"URANUS",  type:"jpl",    class:"major" },
    { key:"Neptune",  label:"NEPTUNE", type:"jpl",    class:"major" },

    { key:"Pluto",    label:"PLUTO",   type:"kepler", body:()=>PLUTO,  class:"small" },
    { key:"Haumea",   label:"HAUMEA",  type:"kepler", body:()=>HAUMEA, class:"small" },
    { key:"Eris",     label:"ERIS",    type:"kepler", body:()=>ERIS,   class:"small" },

    { key:"Kyusei",   label:"KYŪSEI",  type:"kepler", body:()=>KYUSEI, class:"major" }
  ];

  function fillSelect(sel){
    sel.innerHTML = "";
    for(const b of BODIES){
      const opt = document.createElement("option");
      opt.value = b.key;
      opt.textContent = b.label;
      sel.appendChild(opt);
    }
  }
  fillSelect(selA);
  fillSelect(selB);
  selA.value = "Earth";
  selB.value = "Saturn";

  // ---------------------------
  // 4) SVG helpers + layers + glow filter
  // ---------------------------
  function make(tag, attrs = {}){
    const el = document.createElementNS("http://www.w3.org/2000/svg", tag);
    for(const [k,v] of Object.entries(attrs)) el.setAttribute(k, String(v));
    return el;
  }
  function clearSVG(){
    while(svg.firstChild) svg.removeChild(svg.firstChild);
  }
  function setText(el, txt){
    while(el.firstChild) el.removeChild(el.firstChild);
    el.appendChild(document.createTextNode(txt));
  }

  let gWorld, gTrails, gJourney, gHUD;

  function ensureDefs(){
    const defs = make("defs");


    const filter = make("filter", {
  id: "tekugl",
  filterUnits: "objectBoundingBox",
  x: "-0.6",
  y: "-0.6",
  width: "2.2",
  height: "2.2"
});
    filter.appendChild(make("feDropShadow", { dx:"0", dy:"0", stdDeviation:"0.9", "flood-color":"#EBFA7A", "flood-opacity":"0.22" }));
    filter.appendChild(make("feDropShadow", { dx:"0", dy:"0", stdDeviation:"1.6", "flood-color":"#ffcc00", "flood-opacity":"0.18" }));
    defs.appendChild(filter);

const trailBlur = make("filter", {
  id: "trailBlur",
  x: "-0.5",
  y: "-0.5",
  width: "2",
  height: "2"
});
trailBlur.appendChild(make("feGaussianBlur", {
  stdDeviation: "0.35"
}));
defs.appendChild(trailBlur);


      const mask = make("mask", { id: "trailTaperMask" });

const grad = make("linearGradient", {
  id: "trailFadeGrad",
  x1: "0", y1: "0",
  x2: "1", y2: "0",
  gradientUnits: "objectBoundingBox"
});

grad.appendChild(make("stop", { offset: "0%",  "stop-color": "white", "stop-opacity": "1" }));
grad.appendChild(make("stop", { offset: "70%", "stop-color": "white", "stop-opacity": "0.6" }));
grad.appendChild(make("stop", { offset: "100%", "stop-color": "white", "stop-opacity": "0" }));

defs.appendChild(grad);

mask.appendChild(make("rect", {
  x: "-100000",
  y: "-100000",
  width: "200000",
  height: "200000",
  fill: "url(#trailFadeGrad)"
}));

defs.appendChild(mask);
    
    svg.appendChild(defs);
  }

  function buildLayers(){
    gWorld  = make("g", { id:"world" });                  // belts + belt labels (NO glow)
    gTrails = make("g", { id:"trails" });                 // trails (NO glow)
    gJourney= make("g", { id:"journey", filter:"url(#tekugl)" }); // journey line (glow)
    gHUD    = make("g", { id:"hud", filter:"url(#tekugl)" });     // bodies + labels (glow)
    svg.appendChild(gWorld);
    svg.appendChild(gTrails);
    svg.appendChild(gJourney);
    svg.appendChild(gHUD);
  }

   // ---------------------------
  // 5) ViewBox + interaction
  // ---------------------------
  const interaction = {
  pointers: new Map(),
  vb: { x:DEFAULT_VB_X, y:DEFAULT_VB_Y, w:DEFAULT_VB_W, h:DEFAULT_VB_W },
  baseW: WORKING_VB_W,
  justGestured: false,
  gestureTimer: null
};

  function setViewBox(vb){
  interaction.vb = vb;
  svg.setAttribute("viewBox", `${vb.x} ${vb.y} ${vb.w} ${vb.h}`);

  // Re-render so ghost + journey visuals refresh correctly
  render();
}

  function clientToWorld(clientX, clientY){
    const rect = svg.getBoundingClientRect();
    const nx = (clientX - rect.left) / rect.width;
    const ny = (clientY - rect.top) / rect.height;
    return { x: interaction.vb.x + nx * interaction.vb.w, y: interaction.vb.y + ny * interaction.vb.h };
  }

  function dist2(a,b){
    const dx = a.x - b.x, dy = a.y - b.y;
    return Math.sqrt(dx*dx + dy*dy);
  }

  function markGestured(){
    interaction.justGestured = true;
    if(interaction.gestureTimer) clearTimeout(interaction.gestureTimer);
    interaction.gestureTimer = setTimeout(() => interaction.justGestured = false, 180);
  }

  function zoomAt(focusWorld, factor){
    const vb = interaction.vb;
    const nx = (focusWorld.x - vb.x) / vb.w;
    const ny = (focusWorld.y - vb.y) / vb.h;

const MIN_W = 0.2 * WORLD_SCALE;     // prevents deep-zoom precision jitter (scaled world)
const MAX_W = 160000 * WORLD_SCALE;  // scaled world max
    const newW = clamp(vb.w * factor, MIN_W, MAX_W);
    const newH = newW;

    const newX = focusWorld.x - nx * newW;
    const newY = focusWorld.y - ny * newH;

    setViewBox({ x:newX, y:newY, w:newW, h:newH });
    markGestured();
  }

  // Zoom buttons (desktop)
  btnZoomIn.addEventListener("click", (e) => {
    e.preventDefault();
    const focus = { x: interaction.vb.x + interaction.vb.w/2, y: interaction.vb.y + interaction.vb.h/2 };
    zoomAt(focus, 0.82);
  });
  btnZoomOut.addEventListener("click", (e) => {
    e.preventDefault();
    const focus = { x: interaction.vb.x + interaction.vb.w/2, y: interaction.vb.y + interaction.vb.h/2 };
    zoomAt(focus, 1.22);
  });

  // Pointer gestures: ignore if interacting with zoom controls
  wrap.addEventListener("pointerdown", (e) => {
    if(e.target && e.target.closest && e.target.closest(".zoom-corner")) return;
    wrap.setPointerCapture(e.pointerId);
    interaction.pointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
  });
  wrap.addEventListener("pointerup", (e) => { interaction.pointers.delete(e.pointerId); });
  wrap.addEventListener("pointercancel", (e) => { interaction.pointers.delete(e.pointerId); });

  wrap.addEventListener("pointermove", (e) => {
    if(!interaction.pointers.has(e.pointerId)) return;

    const prev = interaction.pointers.get(e.pointerId);
    const curr = { x: e.clientX, y: e.clientY };
    interaction.pointers.set(e.pointerId, curr);

    const pts = Array.from(interaction.pointers.values());

    if(pts.length === 1){
      const dx = curr.x - prev.x;
      const dy = curr.y - prev.y;
      const rect = svg.getBoundingClientRect();
      const wx = (dx / rect.width) * interaction.vb.w;
      const wy = (dy / rect.height) * interaction.vb.h;
      setViewBox({ x: interaction.vb.x - wx, y: interaction.vb.y - wy, w: interaction.vb.w, h: interaction.vb.h });
      markGestured();
      return;
    }

    if(pts.length >= 2){
      const ids = Array.from(interaction.pointers.keys());
      const id1 = ids[0], id2 = ids[1];
      const p1 = interaction.pointers.get(id1);
      const p2 = interaction.pointers.get(id2);

      let b1 = p1, b2 = p2;
      let a1 = p1, a2 = p2;

      if(e.pointerId === id1){ b1 = prev; a1 = curr; }
      else if(e.pointerId === id2){ b2 = prev; a2 = curr; }

      const dBefore = dist2(b1,b2);
      const dAfter  = dist2(a1,a2);
      if(dBefore < 2 || dAfter < 2) return;

      const scale = dBefore / dAfter;
      const midClient = { x:(a1.x+a2.x)/2, y:(a1.y+a2.y)/2 };
      const midWorld = clientToWorld(midClient.x, midClient.y);
      zoomAt(midWorld, scale);
    }
  });

  // Wheel zoom
  wrap.addEventListener("wheel", (e) => {
    if(e.target && e.target.closest && e.target.closest(".zoom-corner")) return;
    e.preventDefault();
    const delta = Math.sign(e.deltaY);
    const factor = delta > 0 ? 1.12 : 0.89;
    zoomAt(clientToWorld(e.clientX, e.clientY), factor);
  }, { passive:false });

  // ---------------------------
  // 6) Date + positions + readout
  // ---------------------------
  function setDateLabel(){
    const jd = currentJD();
    const {y,m,d} = jdToYMD(jd);
    dateEl.textContent = `DEPART: ${y}-${pad2(m)}-${pad2(d)}  (Δ ${dayOffset}d)`;
  }

  function bodyDef(key){ return BODIES.find(b => b.key === key) || null; }

  function bodyPosAndM(key, jd){
  const b = bodyDef(key);
  if(!b) return { pos:{x:0,y:0,z:0}, Mdeg:0 };

  let out;

  if(b.type === "jpl"){
    const o = planetJPL(b.key, jd);
    out = { pos: o.pos, Mdeg: o.el.M, el: o.el };
  }
  else if(b.type === "kepler"){
    const kb = b.body();
    const o = posFromKeplerBody(kb, jd);
    out = { pos: o.pos, Mdeg: o.Mdeg, el: {a:kb.a,e:kb.e,I:kb.I,Omega:kb.Omega,omega:kb.omega} };
  }
  else if(b.type === "l4j") out = { pos: jovianL4Pos(jd), Mdeg:0 };
  else if(b.type === "l5j") out = { pos: jovianL5Pos(jd), Mdeg:0 };
  else if(b.type === "l4s") out = { pos: saturnL4Pos(jd), Mdeg:0 };
  else if(b.type === "l5s") out = { pos: saturnL5Pos(jd), Mdeg:0 };
  else out = { pos:{x:0,y:0,z:0}, Mdeg:0 };

  // SCALE WORLD COORDS ONCE (plot-space)
  return {
    pos: {
      x: out.pos.x * WORLD_SCALE,
      y: out.pos.y * WORLD_SCALE,
      z: out.pos.z * WORLD_SCALE
    },
    Mdeg: out.Mdeg,
    el: out.el
  };
 }

// Sling Drive cruise speed: 2% c
// 0.02c ≈ 3.4629 AU/day
const AU_PER_DAY = 3.4629;

  
  function computeDistanceAU(aKey, bKey, jd){
    const A = bodyPosAndM(aKey, jd).pos;
    const B = bodyPosAndM(bKey, jd).pos;
    const dx = (A.x - B.x) / WORLD_SCALE;
const dy = (A.y - B.y) / WORLD_SCALE;
const dz = (A.z - B.z) / WORLD_SCALE;
return Math.sqrt(dx*dx + dy*dy + dz*dz);
  }

  // ---------------------------
// INTERCEPT SOLVER (ghost target)
// ---------------------------
function solveInterceptDays(aKey, bKey, jd0) {
  const A = bodyPosAndM(aKey, jd0).pos;

  // Initial guess: straight-line snapshot distance
  let t = computeDistanceAU(aKey, bKey, jd0) / AU_PER_DAY;

  // Iterate to converge on moving-target intercept
  for (let i = 0; i < 8; i++) {
    const B = bodyPosAndM(bKey, jd0 + t).pos;

    const dx = (B.x - A.x) / WORLD_SCALE;
    const dy = (B.y - A.y) / WORLD_SCALE;
    const dz = (B.z - A.z) / WORLD_SCALE;

    const dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
    t = dist / AU_PER_DAY;
  }

  return t;
}

  
function updateReadout(){
  const aKey = selA.value;
  const bKey = selB.value;

  const aDef = bodyDef(aKey);
  const bDef = bodyDef(bKey);

  roDepart.textContent = aDef ? aDef.label : aKey;
  roArrive.textContent = bDef ? bDef.label : bKey;

  roDist.textContent = `${fmtAU1(journeyDistanceAU)} AU`;
  roTime.textContent = `${fmtAU1(journeyDays)} d`;

  const fuel = 38.0 + journeyDays;
  roFuel.textContent = `${fmtAU1(fuel)} ā`;
}


  dateEl.addEventListener("click", () => {
    const jd = currentJD();
    const {y,m,d} = jdToYMD(jd);
    const current = `${y}-${pad2(m)}-${pad2(d)}`;
    const s = prompt("Set date (YYYY-MM-DD):", current);
    if(s === null) return;
    const parsed = parseYMD(s);
    if(!parsed){ alert("Invalid date. Use YYYY-MM-DD."); return; }
    const newJD = toJulianDay(parsed.y, parsed.m, parsed.d);
    dayOffset = Math.round(newJD - START_JD);
    dayOffset = clamp(dayOffset, -365250, 365250);
    render();
  });

function stepDays(n){
  dayOffset += n;
  dayOffset = clamp(dayOffset, -365250, 365250);
  render();
}

// --- Hold-to-advance behaviour (PATCH G) ---
function makeHoldStepper(button, direction){
  let holdTimer = null;
  let repeatTimer = null;
  let holding = false;

  const START_DELAY = 800;   // ms before auto-advance starts
  const REPEAT_RATE = 100;   // ms per step once active

  function clearTimers(){
    if(holdTimer){ clearTimeout(holdTimer); holdTimer = null; }
    if(repeatTimer){ clearInterval(repeatTimer); repeatTimer = null; }
    holding = false;
  }

  button.addEventListener("pointerdown", (e) => {
    e.preventDefault();
    holding = true;

    // Immediate single step on press
    stepDays(direction);

    // After delay, begin rapid stepping
    holdTimer = setTimeout(() => {
      if(!holding) return;
      repeatTimer = setInterval(() => {
        stepDays(direction);
      }, REPEAT_RATE);
    }, START_DELAY);
  });

  // Stop on release, cancel, or leaving button
  ["pointerup", "pointercancel", "pointerleave"].forEach(evt => {
    button.addEventListener(evt, clearTimers);
  });
}

// Attach hold behaviour
makeHoldStepper(btnPrev, -1);
makeHoldStepper(btnNext, +1);

btnReset.addEventListener("click", () => {
  dayOffset = 0;
  render();
});


// ---------------------------
// Label placement scheduler (PATCH H)
// ---------------------------
let placementScheduled = false;

function scheduleLabelPlacement(){
  if(placementScheduled) return;
  placementScheduled = true;
  requestAnimationFrame(() => {
    placementScheduled = false;
    updateLabelPlacement();
  });
}
  
  // ---------------------------
  // 7) HUD scaling + declutter + placement (no overlap)
  // ---------------------------
  let hudScale = 1;

  const SIZE = {
    nameBase: 14,   // big
    coordBase: 6,  // smaller
    hitBase: 3
  };

  const PLANET_SIZE_MULT = 10

  const JOURNEY = {
    strokeBase: 0.6,       // thinner
    dotLenBase: 0.1,       // dotted (round cap => dot)
    gapBase:    4
  };

  function updateHUDScale(){
    hudScale = interaction.vb.w / interaction.baseW;
    hudScale = clamp(hudScale, 0.009, 9999999);

    // dots + hit radii scale screen-constant
    if(gHUD){
      gHUD.querySelectorAll("[data-dot]").forEach(el => {
        const base = Number(el.getAttribute("data-dot-base") || "0.16");
        el.setAttribute("r", (base * hudScale).toString());
      });

      gHUD.querySelectorAll("[data-label]").forEach(el => {
        const base = Number(el.getAttribute("data-fs-base") || String(SIZE.nameBase));
        el.setAttribute("font-size", (base * hudScale).toString());
      });
      gHUD.querySelectorAll("[data-coord]").forEach(el => {
        const base = Number(el.getAttribute("data-fs-base") || String(SIZE.coordBase));
        el.setAttribute("font-size", (base * hudScale).toString());
      });
    }

    // journey line stroke scales screen-constant like text
    if(journeyLine){
      journeyLine.setAttribute("stroke-width", String(JOURNEY.strokeBase * hudScale));
      journeyLine.setAttribute("stroke-dasharray", `${JOURNEY.dotLenBase * hudScale} ${JOURNEY.gapBase * hudScale}`);
    }
    // trail stroke widths (screen-constant)
if(gTrails){
  gTrails.querySelectorAll("path").forEach(p => {
    const base = p.__strokeBase;
    if(base) p.setAttribute("stroke-width", String(base * hudScale));
  });
}
  }
  
  const declutter = {
  coordsHideAt: 1200 * WORLD_SCALE,
  smallHideAt: 60 * WORLD_SCALE,
  innerHideAt: 20 * WORLD_SCALE,
  lagrangeHideAt: 30 * WORLD_SCALE
};

  function inView(p){
    const vb = interaction.vb;
    return (p.x >= vb.x && p.x <= vb.x + vb.w && p.y >= vb.y && p.y <= vb.y + vb.h);
  }
function updateDeclutter(){
  const w = interaction.vb.w;

  // Existing tiers
  const coordsOn = w < declutter.coordsHideAt;
  const smallOn  = w < declutter.smallHideAt;
  const innerOn  = w < declutter.innerHideAt;
  const lagOn    = w < declutter.lagrangeHideAt;

  // PATCH G: extreme zoom tier
  // At very large view widths, ONLY Kyūsei + plotted bodies remain
  const EXTREME_HIDE_AT = 1200 * WORLD_SCALE; // deliberately “wayyy out”
  const extreme = w > EXTREME_HIDE_AT;

  const aSel = selA.value;
  const bSel = selB.value;

  if(!gHUD) return;
  const groups = gHUD.querySelectorAll("[data-label-group]");

  groups.forEach(g => {
    const cls = g.getAttribute("data-class") || "major";
    const key = g.getAttribute("data-key") || "";

    const isInner = cls === "inner";
    const isSmall = cls === "small";
    const isMajor = cls === "major";
    const isLag   = cls === "smallL";
    const isKyusei = key === "Kyusei";

    let show = true;

    // PATCH G extreme rule first (overrides everything else)
    if(extreme){
      show = (
        isKyusei ||
        key === aSel ||
        key === bSel
      );
    } else {
      // Normal declutter rules
      if(isSmall && !smallOn) show = false;
      if(isInner && !innerOn) show = false;
      if(isLag   && !lagOn)   show = false;
      if(isMajor) show = true;

      // Selected labels always visible if body is in view
      if((key === aSel || key === bSel) && g.__bodyPos && inView(g.__bodyPos)){
        show = true;
      }
    }

    g.style.opacity = show ? "1" : "0";

    // Coordinate sub-labels
    const coords = g.querySelectorAll("[data-coord]");
    coords.forEach(t => {
      t.style.opacity = (show && coordsOn && !extreme) ? "0.78" : "0";
    });
  });
}


  // Magnetic placement: adjacent, non-overlap, label always in-view if body in-view
  const labelPlacement = {
    offsets: [
      {dx:  0.60, dy: -0.55},
      {dx:  0.60, dy:  0.75},
      {dx: -0.60, dy: -0.55},
      {dx: -0.60, dy:  0.75},
      {dx:  0.00, dy: -0.95},
      {dx:  0.00, dy:  1.10},
    ],
    pad: 0.25
  };

  function estimateTextBox(text, fsWorld){
    const ch = Math.max(1, (text || "").length);
    const w = ch * fsWorld * 0.62;
    const h = fsWorld * 1.10;
    return {w, h};
  }

  function rectsOverlap(a,b){
    return !(a.x + a.w < b.x || b.x + b.w < a.x || a.y + a.h < b.y || b.y + b.h < a.y);
  }
const GOLDEN = 2.399963229728653; // golden angle

function updateLabelPlacement(){
  if(!gHUD) return;

  const groups = gHUD.querySelectorAll("[data-label-group]");
  let i = 0;

  groups.forEach(g => {
    const pos = g.__bodyPos;
    if(!pos) return;

let angle = (i++ * GOLDEN) % (Math.PI * 2);

// Enforce x + y > 0 half-plane
// (cosθ + sinθ > 0)
if (Math.cos(angle) + Math.sin(angle) <= 0) {
  angle = (angle + Math.PI) % (Math.PI * 2);
}
    const r = 0.28 * WORLD_SCALE * hudScale;

    const x = pos.x + Math.cos(angle) * r;
    const y = pos.y + Math.sin(angle) * r;

    const nameT = g.querySelector("[data-label]");
    nameT.setAttribute("x", x);
    nameT.setAttribute("y", y);

    let yCursor = y + Number(nameT.getAttribute("font-size")) * 0.9;
    g.querySelectorAll("[data-coord]").forEach(t => {
      t.setAttribute("x", x);
      t.setAttribute("y", yCursor);
      yCursor += Number(t.getAttribute("font-size")) * 1.1;
    });
  });
}

  // ---------------------------
  // 8) Belts + belt labels (vectorised: do NOT rescale with zoom)
  // ---------------------------

    function addBeltLabelSVG(href, rMid, size, rotationDeg){
  const img = make("image", {
    href,
    x: -size / 2,
    y: -size / 2,
    width: size,
    height: size,
    transform: `rotate(${rotationDeg}) translate(0 ${-rMid})`,
    opacity: "1"
  });
  gWorld.appendChild(img);
}

    
  function circlePath(cx,cy,r){
    return [
      `M ${cx + r} ${cy}`,
      `A ${r} ${r} 0 1 0 ${cx - r} ${cy}`,
      `A ${r} ${r} 0 1 0 ${cx + r} ${cy}`,
      "Z"
    ].join(" ");
  }

  function annulusPath(rIn, rOut){
    const o = circlePath(0,0,rOut);
    const i = circlePath(0,0,rIn);
    return o + " " + i;
  }

  function arcPath(r, centerDeg, spanDeg){
    const a0 = (centerDeg - spanDeg/2) * DEG;
    const a1 = (centerDeg + spanDeg/2) * DEG;
    const x0 = r * Math.cos(a0), y0 = r * Math.sin(a0);
    const x1 = r * Math.cos(a1), y1 = r * Math.sin(a1);
    const largeArc = spanDeg > 180 ? 1 : 0;
    return `M ${x0} ${y0} A ${r} ${r} 0 ${largeArc} 1 ${x1} ${y1}`;
  }

  function drawBand(rIn, rOut, fillOpacity){
    const p = make("path", {
      d: annulusPath(rIn, rOut),
      fill: `rgba(255,204,0,${fillOpacity})`,
      "fill-rule":"evenodd",
      stroke: "none",
      "stroke-width": "0",
      opacity: 1
    });
    gWorld.appendChild(p);
  }



// ---------------------------
// 9) Trails (sampled ephemeris paths)
// ---------------------------

const TRAIL = {
  // multipliers applied to aphelion AU
  // P0..P5 (6 points): the last two points make the "long faint trail" underneath
  samplesAU: [0, 6, 12, 18, 24, 30, 36, 42],
  maxSamples: 8
};


function buildSampledTrail(b, jd){
  // No trails for L-points
  if(b.type === "l4j" || b.type === "l5j" || b.type === "l4s" || b.type === "l5s") return;

  // Get orbital scale (aphelion proxy)
  let aphelionAU = 1;
  if(b.type === "jpl"){
    const el = planetJPL(b.key, jd).el;
    aphelionAU = el.a * (1 + el.e);
  } else if(b.type === "kepler"){
    const kb = b.body();
    aphelionAU = kb.a * (1 + kb.e);
  }

  // Sample past positions (P0..P5)
  const points = [];
  for(let i = 0; i < TRAIL.samplesAU.length; i++){
    const daysBack = TRAIL.samplesAU[i] * aphelionAU;
    const out = bodyPosAndM(b.key, jd - daysBack);
    points.push(out.pos);
  }

  // SAFETY: need at least 4 points to make a spline
  if(points.length < 4) return;

  // Two paths:
  // - LONG (P0..P5) = faint "old" trail underneath
  // - SHORT (P0..P3) = brighter recent trail on top
  const pointsLong  = points;           // all 6 points
  const pointsShort = points.slice(0,4);// first 4 points

  const dLong  = catmullRomSpline(pointsLong, 0.6);
  const dShort = catmullRomSpline(pointsShort, 0.6);

  const minor = (b.class === "small");
  const strokeBase = minor ? 0.45 : 0.55;
  const opacity    = minor ? 0.28 : 0.34;

  // ==========================
  // 1) LONG, faint, blurred trail (under everything)
  // ==========================
  const longTrail = make("path", {
    d: dLong,
    fill: "none",
    stroke: "#ffcc00",
    "stroke-width": String(strokeBase * 2.6 * hudScale),
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    opacity: opacity * 0.16,
    filter: "url(#trailBlur)"
  });
  longTrail.__strokeBase = strokeBase * 2.6;
  gTrails.appendChild(longTrail);

  // ==========================
  // 2) SHORT underlay (your existing glow, but SHORT)
  //    (Mask removed to avoid the misleading gradient trick.)
  // ==========================
  const underlay = make("path", {
    d: dShort,
    fill: "none",
    stroke: "#ffcc00",
    "stroke-width": String(strokeBase * 2.2 * hudScale),
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    opacity: opacity * 0.1,
    filter: "url(#trailBlur)"
  });
  underlay.__strokeBase = strokeBase * 2.2;
  gTrails.appendChild(underlay);

  // ==========================
  // 3) SHORT core (sharp line)
  // ==========================
  const core = make("path", {
    d: dShort,
    fill: "none",
    stroke: "#ffcc00",
    "stroke-width": String(strokeBase * hudScale),
    "stroke-linecap": "round",
    "stroke-linejoin": "round",
    opacity: opacity * 0.1
  });
  core.__strokeBase = strokeBase;
  gTrails.appendChild(core);
}

  
  // ---------------------------
  // 10) Bodies + clusters + journey line
  // ---------------------------
  function hash01(i){
    const s = Math.sin(i * 999.123 + 0.12345) * 43758.5453123;
    return s - Math.floor(s);
  }

  function dotRadiusFor(b){
    if(b.key === "Jupiter") return 0.30;
    if(b.key === "Saturn") return 0.28;
    if(b.key === "Uranus" || b.key === "Neptune") return 0.26;
    if(b.key === "Earth" || b.key === "Venus") return 0.18;
    if(b.key === "Mars") return 0.16;
    if(b.key === "Mercury") return 0.15;
    if(b.class === "small") return 0.14;
    if(b.class === "smallL") return 0.12;
    if(b.key === "Kyusei") return 0.18;
    return 0.16;
  }

  function drawSun(){
    // Removed the outer pale ring (the thing between Mercury and Venus).
    const c1 = make("circle", { cx:0, cy:0, r:0.08 * WORLD_SCALE, fill:"#ffcc00", opacity:"0.85", filter:"url(#tekugl)" });
    gWorld.appendChild(c1);
  }

  function drawBodyAndLabel(b, pos){
    const baseR = dotRadiusFor(b) * PLANET_SIZE_MULT;
    const hitBase = Math.max(SIZE.hitBase, baseR * 6);

    const dot = make("circle", {
      cx: pos.x, cy: pos.y,
      r: (baseR * hudScale),
      fill: "#ffcc00",
      opacity: "0.82",
      "data-dot":"1",
      "data-dot-base": String(baseR)
    });
    gHUD.appendChild(dot);

    const g = make("g", { "data-label-group":"1", "data-class": b.class, "data-key": b.key });
    g.__bodyPos = pos;

    // Slightly smaller labels for minors + L-points
    const isMinorish = (b.class === "small" || b.class === "smallL");
    const nameBase = isMinorish ? (SIZE.nameBase * 0.80) : SIZE.nameBase;
    const coordBase = isMinorish ? (SIZE.coordBase * 0.90) : SIZE.coordBase;

    const nameText = make("text", {
      fill:"#ffcc00",
      "font-family":"monospace",
      "font-weight":"1000",
      "letter-spacing":"0.10em",
      "font-size": String(nameBase * hudScale),
      "data-label":"1",
      "data-fs-base": String(nameBase)
    });
    setText(nameText, b.label);
    g.appendChild(nameText);

    const coordStyle = {
      fill:"#ffcc00",
      "font-family":"monospace",
      "font-weight":"800",
      "letter-spacing":"0.08em",
      opacity:"0.78"
    };

    const cx = make("text", { "data-coord":"1", "data-fs-base": String(coordBase), ...coordStyle });
    setText(cx, `x ${fmtSign(pos.x / WORLD_SCALE, 3)}`);
    g.appendChild(cx);

    const cy = make("text", { "data-coord":"1", "data-fs-base": String(coordBase), ...coordStyle });
    setText(cy, `y ${fmtSign(pos.y / WORLD_SCALE, 3)}`);
    g.appendChild(cy);

    const cz = make("text", { "data-coord":"1", "data-fs-base": String(coordBase), ...coordStyle });
    setText(cz, `z ${fmtSign(pos.z / WORLD_SCALE, 3)}`);
    g.appendChild(cz);

    gHUD.appendChild(g);

    return g;
  }

function drawGhostBody(b, pos) {
  const baseR = dotRadiusFor(b) * PLANET_SIZE_MULT;
  const size = baseR * hudScale * 6;

  const ghost = make("rect", {
    x: pos.x - size / 2,
    y: pos.y - size / 2,
    width: size,
    height: size,
    fill: "#ffcc00",
    opacity: "0.205", // 0.82 * 0.25
    filter: "url(#tekugl)"
  });

  gHUD.appendChild(ghost);
}

  
  function drawLCluster(center, seed){
  // PATCH G:
  // - Dot-like particulate cluster
  // - Elongated (~2x) along orbital tangent
  // - Always perpendicular to Sun vector

const nDots = 0.45 * WORLD_SCALE;      // modest density bump
const stretch = 0.10 * WORLD_SCALE;   // keep length
const jitter  = 0.025 * WORLD_SCALE;  // REAL width  // Vector from Sun (0,0) to L-point

    
  const vx = center.x;
  const vy = center.y;
  const vLen = Math.hypot(vx, vy) || 1;

  // Tangent (perpendicular to Sun vector)
  const tx = -vy / vLen;
  const ty =  vx / vLen;

  for(let i = 0; i < nDots; i++){
    const h1 = hash01(seed + i * 37);
    const h2 = hash01(seed + i * 91);

    // Position along stretched tangent
    const along = (h1 - 0.5) * stretch;

    // Small radial jitter
    const radial = (h2 - 0.5) * jitter;

    const x = center.x
      + tx * along
      + (vx / vLen) * radial;

    const y = center.y
      + ty * along
      + (vy / vLen) * radial;

    const r = 0.035 + h2 * 0.025; // small dots, varied

    const dot = make("circle", {
      cx: x,
      cy: y,
      r: r * hudScale,
      fill: "#ffcc00",
      opacity: 0.55 + h1 * 0.25
    });

    gHUD.appendChild(dot);
  }
}

// ---------------------------
// Journey state (GLOBAL)
// ---------------------------
let journeyGhostPos = null;
let journeyDays = 0;
let journeyDistanceAU = 0;

  // Journey line: dotted, glow, opacity 1, single line
  let journeyLine = null;
  function buildJourneyLine(){
    journeyLine = make("line", {
      x1:"0", y1:"0", x2:"0", y2:"0",
      stroke:"#ffcc00",
      "stroke-linecap":"round",
      opacity:"1.0"
    });
    gJourney.appendChild(journeyLine);
  }
function updateJourneyLine(){
  if(!journeyLine) return;

  const jd = currentJD();
  const aKey = selA.value;
  const bKey = selB.value;

  const A = bodyPosAndM(aKey, jd).pos;

  // Solve intercept
  journeyDays = solveInterceptDays(aKey, bKey, jd);

  const ghostOut = bodyPosAndM(bKey, jd + journeyDays);
  journeyGhostPos = ghostOut.pos;

  // True distance
  const dx = (journeyGhostPos.x - A.x) / WORLD_SCALE;
  const dy = (journeyGhostPos.y - A.y) / WORLD_SCALE;
  const dz = (journeyGhostPos.z - A.z) / WORLD_SCALE;
  journeyDistanceAU = Math.sqrt(dx*dx + dy*dy + dz*dz);

  // Draw journey line
  journeyLine.setAttribute("x1", A.x);
  journeyLine.setAttribute("y1", A.y);
  journeyLine.setAttribute("x2", journeyGhostPos.x);
  journeyLine.setAttribute("y2", journeyGhostPos.y);
}


  selA.addEventListener("change", () => { updateReadout(); updateDeclutter(); updateJourneyLine(); updateLabelPlacement(); render();});
  selB.addEventListener("change", () => { updateReadout(); updateDeclutter(); updateJourneyLine(); updateLabelPlacement(); render();});

  // ---------------------------
  // 11) JPL Horizons hydration for Eris/Haumea
  // ---------------------------
  async function fetchHorizonsElements(spkOrDes){
    const url = `https://ssd.jpl.nasa.gov/api/horizons.api?format=text&COMMAND='${encodeURIComponent(spkOrDes)}'&OBJ_DATA='NO'&MAKE_EPHEM='YES'&EPHEM_TYPE='ELEMENTS'&CENTER='@sun'&START_TIME='2225-06-06'&STOP_TIME='2225-06-07'&STEP_SIZE='1%20d'`;
    const r = await fetch(url, { mode:"cors" });
    const txt = await r.text();

    const i0 = txt.indexOf("$$SOE");
    const i1 = txt.indexOf("$$EOE");
    if(i0 < 0 || i1 < 0) throw new Error("SOE/EOE not found");

    const blob = txt.slice(i0, i1);

    function grab(key){
      const re = new RegExp(`${key}\\s*=\\s*([+\\-\\d\\.E]+)`, "i");
      const m = re.exec(blob);
      return m ? Number(m[1]) : null;
    }

    const EC = grab("EC");
    const IN = grab("IN");
    const OM = grab("OM");
    const W  = grab("\\bW\\b");
    const MA = grab("MA");
    const A  = grab("\\bA\\b");
    const N  = grab("\\bN\\b");
    if([EC,IN,OM,W,MA,A].some(v => v === null || !isFinite(v))) throw new Error("elements incomplete");

    let nDegPerDay = 0.0;
    if(N && isFinite(N)){
      nDegPerDay = (Math.abs(N) < 0.1) ? (N * (180/Math.PI)) : N;
    } else {
      const P_years = Math.sqrt(A*A*A);
      nDegPerDay = 360.0 / (P_years * 365.25);
    }

    return { a:A, e:EC, I:IN, Omega:OM, omega:W, M0:MA, nDegPerDay };
  }

  async function tryHydrateOuterDwarfs(){
    try{
      const er = await fetchHorizonsElements("136199");
      ERIS = makeKeplerBody({ name:"ERIS", a:er.a, e:er.e, I:er.I, Omega:er.Omega, omega:er.omega, epoch_jd: START_JD, M0_deg:er.M0, n_deg_per_day:er.nDegPerDay, isMinor:true });
    } catch(_){}
    try{
      const ha = await fetchHorizonsElements("136108");
      HAUMEA = makeKeplerBody({ name:"HAUMEA", a:ha.a, e:ha.e, I:ha.I, Omega:ha.Omega, omega:ha.omega, epoch_jd: START_JD, M0_deg:ha.M0, n_deg_per_day:ha.nDegPerDay, isMinor:true });
    } catch(_){}
  }

  // ---------------------------
  // 12) Render
  // ---------------------------
  function render(){
    const jd = currentJD();

    clearSVG();
    ensureDefs();
    buildLayers();

    const defs = svg.querySelector("defs");

// --- WILD WASTE ---
drawBand(2.10 * WORLD_SCALE, 3.30 * WORLD_SCALE, 0.05);
addBeltLabelSVG("belt-wild-waste.svg", 0 * WORLD_SCALE, 6 * WORLD_SCALE, 0);
addBeltLabelSVG("belt-wild-waste.svg", 0 * WORLD_SCALE, 6 * WORLD_SCALE, 180);

// --- SECOND CROWN ---
drawBand(30.0 * WORLD_SCALE, 50.0 * WORLD_SCALE, 0.03);
addBeltLabelSVG("belt-second-crown.svg", 0 * WORLD_SCALE, 86 * WORLD_SCALE, 0);
addBeltLabelSVG("belt-second-crown.svg", 0 * WORLD_SCALE, 86 * WORLD_SCALE, 180);

// --- OORT CLOUD ---
drawBand(2000.0 * WORLD_SCALE, 100000.0 * WORLD_SCALE, 0.010);
addBeltLabelSVG("belt-oort-cloud.svg", 0 * WORLD_SCALE, 6000 * WORLD_SCALE, 0);
addBeltLabelSVG("belt-oort-cloud.svg", 0 * WORLD_SCALE, 6000 * WORLD_SCALE, 180);

   
    drawSun();

    buildJourneyLine();

// Trails: sampled ephemeris trails
for(const b of BODIES){
  buildSampledTrail(b, jd);
}
    
    // Bodies + labels
    for(const b of BODIES){
      const out = bodyPosAndM(b.key, jd);
      const pos = out.pos;

      if(b.key === "Ju-L4") drawLCluster(pos, 1000);
      if(b.key === "Ju-L5") drawLCluster(pos, 2000);
      if(b.key === "Sa-L4") drawLCluster(pos, 3000);
      if(b.key === "Sa-L5") drawLCluster(pos, 4000);

      drawBodyAndLabel(b, pos);
    }



    
    setDateLabel();
    updateReadout();

    updateJourneyLine();

// Ghost destination marker
if(journeyGhostPos){
  const bDef = bodyDef(selB.value);
  if(bDef){
    drawGhostBody(bDef, journeyGhostPos);
  }
}
    
    updateHUDScale();
    updateDeclutter();
    updateLabelPlacement();
  }

  // Initial viewbox
  setViewBox({ x:DEFAULT_VB_X, y:DEFAULT_VB_Y, w:DEFAULT_VB_W, h:DEFAULT_VB_W });

  // Hydrate dwarfs, then rerender
  (async () => {
    await tryHydrateOuterDwarfs();
    render();
  })();

  render();

})();
</script>

</body>
</html>
